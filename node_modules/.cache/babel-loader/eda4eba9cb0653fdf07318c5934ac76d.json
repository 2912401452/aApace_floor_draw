{"ast":null,"code":"module.exports = function () {\n  throw new Error('call .point() or .polygon() instead');\n};\n\nfunction position(bbox) {\n  if (bbox) return coordInBBBOX(bbox);else return [lon(), lat()];\n}\n\nmodule.exports.position = position;\n\nmodule.exports.point = function (count, bbox) {\n  var features = [];\n\n  for (i = 0; i < count; i++) {\n    features.push(feature(bbox ? point(position(bbox)) : point()));\n  }\n\n  return collection(features);\n};\n\nmodule.exports.polygon = function (count, num_vertices, max_radial_length, bbox) {\n  if (typeof num_vertices !== 'number') num_vertices = 10;\n  if (typeof max_radial_length !== 'number') max_radial_length = 10;\n  var features = [];\n\n  for (i = 0; i < count; i++) {\n    var vertices = [],\n        circle_offsets = Array.apply(null, new Array(num_vertices + 1)).map(Math.random);\n    circle_offsets.forEach(sumOffsets);\n    circle_offsets.forEach(scaleOffsets);\n    vertices[vertices.length - 1] = vertices[0]; // close the ring\n    // center the polygon around something\n\n    vertices = vertices.map(vertexToCoordinate(position(bbox)));\n    features.push(feature(polygon([vertices])));\n  }\n\n  function sumOffsets(cur, index, arr) {\n    arr[index] = index > 0 ? cur + arr[index - 1] : cur;\n  }\n\n  function scaleOffsets(cur, index) {\n    cur = cur * 2 * Math.PI / circle_offsets[circle_offsets.length - 1];\n    var radial_scaler = Math.random();\n    vertices.push([radial_scaler * max_radial_length * Math.sin(cur), radial_scaler * max_radial_length * Math.cos(cur)]);\n  }\n\n  return collection(features);\n};\n\nfunction vertexToCoordinate(hub) {\n  return function (cur, index) {\n    return [cur[0] + hub[0], cur[1] + hub[1]];\n  };\n}\n\nfunction rnd() {\n  return Math.random() - 0.5;\n}\n\nfunction lon() {\n  return rnd() * 360;\n}\n\nfunction lat() {\n  return rnd() * 180;\n}\n\nfunction point(coordinates) {\n  return {\n    type: 'Point',\n    coordinates: coordinates || [lon(), lat()]\n  };\n}\n\nfunction coordInBBBOX(bbox) {\n  return [Math.random() * (bbox[2] - bbox[0]) + bbox[0], Math.random() * (bbox[3] - bbox[1]) + bbox[1]];\n}\n\nfunction pointInBBBOX() {\n  return {\n    type: 'Point',\n    coordinates: [lon(), lat()]\n  };\n}\n\nfunction polygon(coordinates) {\n  return {\n    type: 'Polygon',\n    coordinates: coordinates\n  };\n}\n\nfunction feature(geom) {\n  return {\n    type: 'Feature',\n    geometry: geom,\n    properties: {}\n  };\n}\n\nfunction collection(f) {\n  return {\n    type: 'FeatureCollection',\n    features: f\n  };\n}","map":{"version":3,"sources":["/Users/yiqianyao/workspace/something/floorcanvas/node_modules/geojson-random/index.js"],"names":["module","exports","Error","position","bbox","coordInBBBOX","lon","lat","point","count","features","i","push","feature","collection","polygon","num_vertices","max_radial_length","vertices","circle_offsets","Array","apply","map","Math","random","forEach","sumOffsets","scaleOffsets","length","vertexToCoordinate","cur","index","arr","PI","radial_scaler","sin","cos","hub","rnd","coordinates","type","pointInBBBOX","geom","geometry","properties","f"],"mappings":"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","sourcesContent":["module.exports = function() {\n    throw new Error('call .point() or .polygon() instead');\n};\n\nfunction position(bbox) {\n    if (bbox) return coordInBBBOX(bbox);\n    else return [lon(), lat()];\n}\n\nmodule.exports.position = position;\n\nmodule.exports.point = function(count, bbox) {\n    var features = [];\n    for (i = 0; i < count; i++) {\n        features.push(feature(bbox ? point(position(bbox)) : point()));\n    }\n    return collection(features);\n};\n\nmodule.exports.polygon = function(count, num_vertices, max_radial_length, bbox) {\n    if (typeof num_vertices !== 'number') num_vertices = 10;\n    if (typeof max_radial_length !== 'number') max_radial_length = 10;\n    var features = [];\n    for (i = 0; i < count; i++) {\n        var vertices = [],\n            circle_offsets = Array.apply(null,\n                new Array(num_vertices + 1)).map(Math.random);\n\n        circle_offsets.forEach(sumOffsets);\n        circle_offsets.forEach(scaleOffsets);\n        vertices[vertices.length - 1] = vertices[0]; // close the ring\n\n        // center the polygon around something\n        vertices = vertices.map(vertexToCoordinate(position(bbox)));\n        features.push(feature(polygon([vertices])));\n    }\n\n    function sumOffsets(cur, index, arr) {\n        arr[index] = (index > 0) ? cur + arr[index - 1] : cur;\n    }\n\n    function scaleOffsets(cur, index) {\n        cur = cur * 2 * Math.PI / circle_offsets[circle_offsets.length - 1];\n        var radial_scaler = Math.random();\n        vertices.push([\n            radial_scaler * max_radial_length * Math.sin(cur),\n            radial_scaler * max_radial_length * Math.cos(cur)\n        ]);\n    }\n\n    return collection(features);\n};\n\n\nfunction vertexToCoordinate(hub) {\n    return function(cur, index) { return [cur[0] + hub[0], cur[1] + hub[1]]; };\n}\n\nfunction rnd() { return Math.random() - 0.5; }\nfunction lon() { return rnd() * 360; }\nfunction lat() { return rnd() * 180; }\n\nfunction point(coordinates) {\n    return {\n        type: 'Point',\n        coordinates: coordinates || [lon(), lat()]\n    };\n}\n\nfunction coordInBBBOX(bbox) {\n    return [\n        (Math.random() * (bbox[2] - bbox[0])) + bbox[0],\n        (Math.random() * (bbox[3] - bbox[1])) + bbox[1]];\n}\n\nfunction pointInBBBOX() {\n    return {\n        type: 'Point',\n        coordinates: [lon(), lat()]\n    };\n}\n\nfunction polygon(coordinates) {\n    return {\n        type: 'Polygon',\n        coordinates: coordinates\n    };\n}\n\nfunction feature(geom) {\n    return {\n        type: 'Feature',\n        geometry: geom,\n        properties: {}\n    };\n}\n\nfunction collection(f) {\n    return {\n        type: 'FeatureCollection',\n        features: f\n    };\n}\n"]},"metadata":{},"sourceType":"script"}