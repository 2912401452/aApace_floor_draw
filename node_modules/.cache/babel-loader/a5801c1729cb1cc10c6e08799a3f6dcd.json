{"ast":null,"code":"var featureCollection = require('turf-helpers').featureCollection;\n\nvar centroid = require('turf-center');\n\nvar distance = require('turf-distance');\n\nvar inside = require('turf-inside');\n\nvar explode = require('turf-explode');\n/**\n * Takes a feature and returns a {@link Point} guaranteed to be on the surface of the feature.\n *\n * * Given a {@link Polygon}, the point will be in the area of the polygon\n * * Given a {@link LineString}, the point will be along the string\n * * Given a {@link Point}, the point will the same as the input\n *\n * @param {(Feature|FeatureCollection)} fc any feature or set of features\n * @returns {Feature} a point on the surface of `input`\n * @example\n * // create a random polygon\n * var polygon = turf.random('polygon');\n *\n * //=polygon\n *\n * var pointOnPolygon = turf.pointOnSurface(polygon);\n *\n* var resultFeatures = polygon.features.concat(pointOnPolygon);\n* var result = {\n*   \"type\": \"FeatureCollection\",\n*   \"features\": resultFeatures\n* };\n *\n * //=result\n */\n\n\nfunction pointOnSurface(fc) {\n  // normalize\n  if (fc.type !== 'FeatureCollection') {\n    if (fc.type !== 'Feature') {\n      fc = {\n        type: 'Feature',\n        geometry: fc,\n        properties: {}\n      };\n    }\n\n    fc = featureCollection([fc]);\n  } //get centroid\n\n\n  var cent = centroid(fc); // check to see if centroid is on surface\n\n  var onSurface = false;\n  var i = 0;\n\n  while (!onSurface && i < fc.features.length) {\n    var geom = fc.features[i].geometry;\n    var x, y, x1, y1, x2, y2, k;\n    var onLine = false;\n\n    if (geom.type === 'Point') {\n      if (cent.geometry.coordinates[0] === geom.coordinates[0] && cent.geometry.coordinates[1] === geom.coordinates[1]) {\n        onSurface = true;\n      }\n    } else if (geom.type === 'MultiPoint') {\n      var onMultiPoint = false;\n      k = 0;\n\n      while (!onMultiPoint && k < geom.coordinates.length) {\n        if (cent.geometry.coordinates[0] === geom.coordinates[k][0] && cent.geometry.coordinates[1] === geom.coordinates[k][1]) {\n          onSurface = true;\n          onMultiPoint = true;\n        }\n\n        k++;\n      }\n    } else if (geom.type === 'LineString') {\n      k = 0;\n\n      while (!onLine && k < geom.coordinates.length - 1) {\n        x = cent.geometry.coordinates[0];\n        y = cent.geometry.coordinates[1];\n        x1 = geom.coordinates[k][0];\n        y1 = geom.coordinates[k][1];\n        x2 = geom.coordinates[k + 1][0];\n        y2 = geom.coordinates[k + 1][1];\n\n        if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n          onLine = true;\n          onSurface = true;\n        }\n\n        k++;\n      }\n    } else if (geom.type === 'MultiLineString') {\n      var j = 0;\n\n      while (j < geom.coordinates.length) {\n        onLine = false;\n        k = 0;\n        var line = geom.coordinates[j];\n\n        while (!onLine && k < line.length - 1) {\n          x = cent.geometry.coordinates[0];\n          y = cent.geometry.coordinates[1];\n          x1 = line[k][0];\n          y1 = line[k][1];\n          x2 = line[k + 1][0];\n          y2 = line[k + 1][1];\n\n          if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n            onLine = true;\n            onSurface = true;\n          }\n\n          k++;\n        }\n\n        j++;\n      }\n    } else if (geom.type === 'Polygon' || geom.type === 'MultiPolygon') {\n      var f = {\n        type: 'Feature',\n        geometry: geom,\n        properties: {}\n      };\n\n      if (inside(cent, f)) {\n        onSurface = true;\n      }\n    }\n\n    i++;\n  }\n\n  if (onSurface) {\n    return cent;\n  } else {\n    var vertices = featureCollection([]);\n\n    for (i = 0; i < fc.features.length; i++) {\n      vertices.features = vertices.features.concat(explode(fc.features[i]).features);\n    }\n\n    var closestVertex;\n    var closestDistance = Infinity;\n\n    for (i = 0; i < vertices.features.length; i++) {\n      var dist = distance(cent, vertices.features[i], 'miles');\n\n      if (dist < closestDistance) {\n        closestDistance = dist;\n        closestVertex = vertices.features[i];\n      }\n    }\n\n    return closestVertex;\n  }\n}\n\nfunction pointOnSegment(x, y, x1, y1, x2, y2) {\n  var ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  var ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n  var pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));\n\n  if (ab === ap + pb) {\n    return true;\n  }\n}\n\nmodule.exports = pointOnSurface;","map":{"version":3,"sources":["/Users/yiqianyao/workspace/something/aApace_floor_draw/node_modules/turf-point-on-surface/index.js"],"names":["featureCollection","require","centroid","distance","inside","explode","pointOnSurface","fc","type","geometry","properties","cent","onSurface","i","features","length","geom","x","y","x1","y1","x2","y2","k","onLine","coordinates","onMultiPoint","pointOnSegment","j","line","f","vertices","concat","closestVertex","closestDistance","Infinity","dist","ab","Math","sqrt","ap","pb","module","exports"],"mappings":"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","sourcesContent":["var featureCollection = require('turf-helpers').featureCollection;\nvar centroid = require('turf-center');\nvar distance = require('turf-distance');\nvar inside = require('turf-inside');\nvar explode = require('turf-explode');\n\n/**\n * Takes a feature and returns a {@link Point} guaranteed to be on the surface of the feature.\n *\n * * Given a {@link Polygon}, the point will be in the area of the polygon\n * * Given a {@link LineString}, the point will be along the string\n * * Given a {@link Point}, the point will the same as the input\n *\n * @param {(Feature|FeatureCollection)} fc any feature or set of features\n * @returns {Feature} a point on the surface of `input`\n * @example\n * // create a random polygon\n * var polygon = turf.random('polygon');\n *\n * //=polygon\n *\n * var pointOnPolygon = turf.pointOnSurface(polygon);\n *\n* var resultFeatures = polygon.features.concat(pointOnPolygon);\n* var result = {\n*   \"type\": \"FeatureCollection\",\n*   \"features\": resultFeatures\n* };\n *\n * //=result\n */\nfunction pointOnSurface(fc) {\n    // normalize\n    if (fc.type !== 'FeatureCollection') {\n        if (fc.type !== 'Feature') {\n            fc = {\n                type: 'Feature',\n                geometry: fc,\n                properties: {}\n            };\n        }\n        fc = featureCollection([fc]);\n    }\n\n    //get centroid\n    var cent = centroid(fc);\n\n    // check to see if centroid is on surface\n    var onSurface = false;\n    var i = 0;\n    while (!onSurface && i < fc.features.length) {\n        var geom = fc.features[i].geometry;\n        var x, y, x1, y1, x2, y2, k;\n        var onLine = false;\n        if (geom.type === 'Point') {\n            if (cent.geometry.coordinates[0] === geom.coordinates[0] &&\n        cent.geometry.coordinates[1] === geom.coordinates[1]) {\n                onSurface = true;\n            }\n        } else if (geom.type === 'MultiPoint') {\n            var onMultiPoint = false;\n            k = 0;\n            while (!onMultiPoint && k < geom.coordinates.length) {\n                if (cent.geometry.coordinates[0] === geom.coordinates[k][0] &&\n          cent.geometry.coordinates[1] === geom.coordinates[k][1]) {\n                    onSurface = true;\n                    onMultiPoint = true;\n                }\n                k++;\n            }\n        } else if (geom.type === 'LineString') {\n            k = 0;\n            while (!onLine && k < geom.coordinates.length - 1) {\n                x = cent.geometry.coordinates[0];\n                y = cent.geometry.coordinates[1];\n                x1 = geom.coordinates[k][0];\n                y1 = geom.coordinates[k][1];\n                x2 = geom.coordinates[k + 1][0];\n                y2 = geom.coordinates[k + 1][1];\n                if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n                    onLine = true;\n                    onSurface = true;\n                }\n                k++;\n            }\n        } else if (geom.type === 'MultiLineString') {\n            var j = 0;\n            while (j < geom.coordinates.length) {\n                onLine = false;\n                k = 0;\n                var line = geom.coordinates[j];\n                while (!onLine && k < line.length - 1) {\n                    x = cent.geometry.coordinates[0];\n                    y = cent.geometry.coordinates[1];\n                    x1 = line[k][0];\n                    y1 = line[k][1];\n                    x2 = line[k + 1][0];\n                    y2 = line[k + 1][1];\n                    if (pointOnSegment(x, y, x1, y1, x2, y2)) {\n                        onLine = true;\n                        onSurface = true;\n                    }\n                    k++;\n                }\n                j++;\n            }\n        } else if (geom.type === 'Polygon' || geom.type === 'MultiPolygon') {\n            var f = {\n                type: 'Feature',\n                geometry: geom,\n                properties: {}\n            };\n            if (inside(cent, f)) {\n                onSurface = true;\n            }\n        }\n        i++;\n    }\n    if (onSurface) {\n        return cent;\n    } else {\n        var vertices = featureCollection([]);\n        for (i = 0; i < fc.features.length; i++) {\n            vertices.features = vertices.features.concat(explode(fc.features[i]).features);\n        }\n        var closestVertex;\n        var closestDistance = Infinity;\n        for (i = 0; i < vertices.features.length; i++) {\n            var dist = distance(cent, vertices.features[i], 'miles');\n            if (dist < closestDistance) {\n                closestDistance = dist;\n                closestVertex = vertices.features[i];\n            }\n        }\n        return closestVertex;\n    }\n}\n\nfunction pointOnSegment(x, y, x1, y1, x2, y2) {\n    var ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    var ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n    var pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));\n    if (ab === ap + pb) {\n        return true;\n    }\n}\n\nmodule.exports = pointOnSurface;\n"]},"metadata":{},"sourceType":"script"}