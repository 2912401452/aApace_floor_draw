{"ast":null,"code":"var invariant = require('turf-invariant'); // http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point resides inside the polygon. The polygon can\n * be convex or concave. The function accounts for holes.\n *\n * @name inside\n * @param {Feature<Point>} point input point\n * @param {Feature<(Polygon|MultiPolygon)>} polygon input polygon or multipolygon\n * @return {Boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt1 = {\n *   \"type\": \"Feature\",\n *   \"properties\": {\n *     \"marker-color\": \"#f00\"\n *   },\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-111.467285, 40.75766]\n *   }\n * };\n * var pt2 = {\n *   \"type\": \"Feature\",\n *   \"properties\": {\n *     \"marker-color\": \"#0f0\"\n *   },\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-111.873779, 40.647303]\n *   }\n * };\n * var poly = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Polygon\",\n *     \"coordinates\": [[\n *       [-112.074279, 40.52215],\n *       [-112.074279, 40.853293],\n *       [-111.610107, 40.853293],\n *       [-111.610107, 40.52215],\n *       [-112.074279, 40.52215]\n *     ]]\n *   }\n * };\n *\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [pt1, pt2, poly]\n * };\n *\n * //=features\n *\n * var isInside1 = turf.inside(pt1, poly);\n * //=isInside1\n *\n * var isInside2 = turf.inside(pt2, poly);\n * //=isInside2\n */\n\n\nmodule.exports = function input(point, polygon) {\n  var pt = invariant.getCoord(point);\n  var polys = polygon.geometry.coordinates; // normalize to multipolygon\n\n  if (polygon.geometry.type === 'Polygon') polys = [polys];\n\n  for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {\n    // check if it is in the outer ring first\n    if (inRing(pt, polys[i][0])) {\n      var inHole = false;\n      var k = 1; // check for the point in any of the holes\n\n      while (k < polys[i].length && !inHole) {\n        if (inRing(pt, polys[i][k])) {\n          inHole = true;\n        }\n\n        k++;\n      }\n\n      if (!inHole) insidePoly = true;\n    }\n  }\n\n  return insidePoly;\n}; // pt is [x,y] and ring is [[x,y], [x,y],..]\n\n\nfunction inRing(pt, ring) {\n  var isInside = false;\n\n  for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n    var xi = ring[i][0],\n        yi = ring[i][1];\n    var xj = ring[j][0],\n        yj = ring[j][1];\n    var intersect = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;\n    if (intersect) isInside = !isInside;\n  }\n\n  return isInside;\n}","map":{"version":3,"sources":["/Users/yiqianyao/workspace/something/aApace_floor_draw/node_modules/turf-inside/index.js"],"names":["invariant","require","module","exports","input","point","polygon","pt","getCoord","polys","geometry","coordinates","type","i","insidePoly","length","inRing","inHole","k","ring","isInside","j","xi","yi","xj","yj","intersect"],"mappings":"AAAA,IAAIA,SAAS,GAAGC,OAAO,CAAC,gBAAD,CAAvB,C,CAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP,GAAiB,SAASC,KAAT,CAAeC,KAAf,EAAsBC,OAAtB,EAA+B;AAC5C,MAAIC,EAAE,GAAGP,SAAS,CAACQ,QAAV,CAAmBH,KAAnB,CAAT;AACA,MAAII,KAAK,GAAGH,OAAO,CAACI,QAAR,CAAiBC,WAA7B,CAF4C,CAG5C;;AACA,MAAIL,OAAO,CAACI,QAAR,CAAiBE,IAAjB,KAA0B,SAA9B,EAAyCH,KAAK,GAAG,CAACA,KAAD,CAAR;;AAEzC,OAAK,IAAII,CAAC,GAAG,CAAR,EAAWC,UAAU,GAAG,KAA7B,EAAoCD,CAAC,GAAGJ,KAAK,CAACM,MAAV,IAAoB,CAACD,UAAzD,EAAqED,CAAC,EAAtE,EAA0E;AACtE;AACA,QAAIG,MAAM,CAACT,EAAD,EAAKE,KAAK,CAACI,CAAD,CAAL,CAAS,CAAT,CAAL,CAAV,EAA6B;AACzB,UAAII,MAAM,GAAG,KAAb;AACA,UAAIC,CAAC,GAAG,CAAR,CAFyB,CAGzB;;AACA,aAAOA,CAAC,GAAGT,KAAK,CAACI,CAAD,CAAL,CAASE,MAAb,IAAuB,CAACE,MAA/B,EAAuC;AACnC,YAAID,MAAM,CAACT,EAAD,EAAKE,KAAK,CAACI,CAAD,CAAL,CAASK,CAAT,CAAL,CAAV,EAA6B;AACzBD,UAAAA,MAAM,GAAG,IAAT;AACH;;AACDC,QAAAA,CAAC;AACJ;;AACD,UAAI,CAACD,MAAL,EAAaH,UAAU,GAAG,IAAb;AAChB;AACJ;;AACD,SAAOA,UAAP;AACH,CAtBD,C,CAwBA;;;AACA,SAASE,MAAT,CAAgBT,EAAhB,EAAoBY,IAApB,EAA0B;AACtB,MAAIC,QAAQ,GAAG,KAAf;;AACA,OAAK,IAAIP,CAAC,GAAG,CAAR,EAAWQ,CAAC,GAAGF,IAAI,CAACJ,MAAL,GAAc,CAAlC,EAAqCF,CAAC,GAAGM,IAAI,CAACJ,MAA9C,EAAsDM,CAAC,GAAGR,CAAC,EAA3D,EAA+D;AAC3D,QAAIS,EAAE,GAAGH,IAAI,CAACN,CAAD,CAAJ,CAAQ,CAAR,CAAT;AAAA,QAAqBU,EAAE,GAAGJ,IAAI,CAACN,CAAD,CAAJ,CAAQ,CAAR,CAA1B;AACA,QAAIW,EAAE,GAAGL,IAAI,CAACE,CAAD,CAAJ,CAAQ,CAAR,CAAT;AAAA,QAAqBI,EAAE,GAAGN,IAAI,CAACE,CAAD,CAAJ,CAAQ,CAAR,CAA1B;AACA,QAAIK,SAAS,GAAKH,EAAE,GAAGhB,EAAE,CAAC,CAAD,CAAR,KAAkBkB,EAAE,GAAGlB,EAAE,CAAC,CAAD,CAA1B,IACfA,EAAE,CAAC,CAAD,CAAF,GAAQ,CAACiB,EAAE,GAAGF,EAAN,KAAaf,EAAE,CAAC,CAAD,CAAF,GAAQgB,EAArB,KAA4BE,EAAE,GAAGF,EAAjC,IAAuCD,EADhD;AAEA,QAAII,SAAJ,EAAeN,QAAQ,GAAG,CAACA,QAAZ;AAClB;;AACD,SAAOA,QAAP;AACH","sourcesContent":["var invariant = require('turf-invariant');\n\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point resides inside the polygon. The polygon can\n * be convex or concave. The function accounts for holes.\n *\n * @name inside\n * @param {Feature<Point>} point input point\n * @param {Feature<(Polygon|MultiPolygon)>} polygon input polygon or multipolygon\n * @return {Boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt1 = {\n *   \"type\": \"Feature\",\n *   \"properties\": {\n *     \"marker-color\": \"#f00\"\n *   },\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-111.467285, 40.75766]\n *   }\n * };\n * var pt2 = {\n *   \"type\": \"Feature\",\n *   \"properties\": {\n *     \"marker-color\": \"#0f0\"\n *   },\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-111.873779, 40.647303]\n *   }\n * };\n * var poly = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Polygon\",\n *     \"coordinates\": [[\n *       [-112.074279, 40.52215],\n *       [-112.074279, 40.853293],\n *       [-111.610107, 40.853293],\n *       [-111.610107, 40.52215],\n *       [-112.074279, 40.52215]\n *     ]]\n *   }\n * };\n *\n * var features = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [pt1, pt2, poly]\n * };\n *\n * //=features\n *\n * var isInside1 = turf.inside(pt1, poly);\n * //=isInside1\n *\n * var isInside2 = turf.inside(pt2, poly);\n * //=isInside2\n */\nmodule.exports = function input(point, polygon) {\n    var pt = invariant.getCoord(point);\n    var polys = polygon.geometry.coordinates;\n    // normalize to multipolygon\n    if (polygon.geometry.type === 'Polygon') polys = [polys];\n\n    for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0])) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k])) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) insidePoly = true;\n        }\n    }\n    return insidePoly;\n};\n\n// pt is [x,y] and ring is [[x,y], [x,y],..]\nfunction inRing(pt, ring) {\n    var isInside = false;\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0], yi = ring[i][1];\n        var xj = ring[j][0], yj = ring[j][1];\n        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&\n        (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);\n        if (intersect) isInside = !isInside;\n    }\n    return isInside;\n}\n"]},"metadata":{},"sourceType":"script"}