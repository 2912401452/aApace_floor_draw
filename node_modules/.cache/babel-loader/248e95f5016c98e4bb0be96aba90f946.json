{"ast":null,"code":"var distance = require('turf-distance');\n\nvar point = require('turf-helpers').point;\n\nvar bearing = require('turf-bearing');\n\nvar destination = require('turf-destination');\n/**\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the LineString.\n *\n * @name pointOnLine\n * @param {Feature<LineString>} line line to snap to\n * @param {Feature<Point>} point point to snap from\n * @return {Feature<Point>} closest point on the `line` to `point`\n * @example\n * var line = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [\n *       [-77.031669, 38.878605],\n *       [-77.029609, 38.881946],\n *       [-77.020339, 38.884084],\n *       [-77.025661, 38.885821],\n *       [-77.021884, 38.889563],\n *       [-77.019824, 38.892368]\n *     ]\n *   }\n * };\n * var pt = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-77.037076, 38.884017]\n *   }\n * };\n *\n * var snapped = turf.pointOnLine(line, pt);\n * snapped.properties['marker-color'] = '#00f'\n *\n * var result = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [line, pt, snapped]\n * };\n *\n * //=result\n */\n\n\nmodule.exports = function (line, pt) {\n  var coords;\n\n  if (line.type === 'Feature') {\n    coords = line.geometry.coordinates;\n  } else if (line.type === 'LineString') {\n    coords = line.coordinates;\n  } else {\n    throw new Error('input must be a LineString Feature or Geometry');\n  }\n\n  return pointOnLine(pt, coords);\n};\n\nfunction pointOnLine(pt, coords) {\n  var units = 'miles';\n  var closestPt = point([Infinity, Infinity], {\n    dist: Infinity\n  });\n\n  for (var i = 0; i < coords.length - 1; i++) {\n    var start = point(coords[i]);\n    var stop = point(coords[i + 1]); //start\n\n    start.properties.dist = distance(pt, start, units); //stop\n\n    stop.properties.dist = distance(pt, stop, units); //perpendicular\n\n    var heightDistance = Math.max(start.properties.dist, stop.properties.dist);\n    var direction = bearing(start, stop);\n    var perpendicularPt1 = destination(pt, heightDistance, direction + 90, units);\n    var perpendicularPt2 = destination(pt, heightDistance, direction - 90, units);\n    var intersect = lineIntersects(perpendicularPt1.geometry.coordinates[0], perpendicularPt1.geometry.coordinates[1], perpendicularPt2.geometry.coordinates[0], perpendicularPt2.geometry.coordinates[1], start.geometry.coordinates[0], start.geometry.coordinates[1], stop.geometry.coordinates[0], stop.geometry.coordinates[1]);\n    var intersectPt;\n\n    if (intersect) {\n      intersectPt = point(intersect);\n      intersectPt.properties.dist = distance(pt, intersectPt, units);\n    }\n\n    if (start.properties.dist < closestPt.properties.dist) {\n      closestPt = start;\n      closestPt.properties.index = i;\n    }\n\n    if (stop.properties.dist < closestPt.properties.dist) {\n      closestPt = stop;\n      closestPt.properties.index = i;\n    }\n\n    if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n      closestPt = intersectPt;\n      closestPt.properties.index = i;\n    }\n  }\n\n  return closestPt;\n} // modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/\n\n\nfunction lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {\n  // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point\n  var denominator, a, b, numerator1, numerator2;\n  var result = {\n    x: null,\n    y: null,\n    onLine1: false,\n    onLine2: false\n  };\n  denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);\n\n  if (denominator === 0) {\n    if (result.x !== null && result.y !== null) {\n      return result;\n    } else {\n      return false;\n    }\n  }\n\n  a = line1StartY - line2StartY;\n  b = line1StartX - line2StartX;\n  numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;\n  numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;\n  a = numerator1 / denominator;\n  b = numerator2 / denominator; // if we cast these lines infinitely in both directions, they intersect here:\n\n  result.x = line1StartX + a * (line1EndX - line1StartX);\n  result.y = line1StartY + a * (line1EndY - line1StartY); // if line1 is a segment and line2 is infinite, they intersect if:\n\n  if (a > 0 && a < 1) {\n    result.onLine1 = true;\n  } // if line2 is a segment and line1 is infinite, they intersect if:\n\n\n  if (b > 0 && b < 1) {\n    result.onLine2 = true;\n  } // if line1 and line2 are segments, they intersect if both of the above are true\n\n\n  if (result.onLine1 && result.onLine2) {\n    return [result.x, result.y];\n  } else {\n    return false;\n  }\n}","map":{"version":3,"sources":["/Users/yiqianyao/workspace/something/floorcanvas/node_modules/turf-point-on-line/index.js"],"names":["distance","require","point","bearing","destination","module","exports","line","pt","coords","type","geometry","coordinates","Error","pointOnLine","units","closestPt","Infinity","dist","i","length","start","stop","properties","heightDistance","Math","max","direction","perpendicularPt1","perpendicularPt2","intersect","lineIntersects","intersectPt","index","line1StartX","line1StartY","line1EndX","line1EndY","line2StartX","line2StartY","line2EndX","line2EndY","denominator","a","b","numerator1","numerator2","result","x","y","onLine1","onLine2"],"mappings":"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","sourcesContent":["var distance = require('turf-distance');\nvar point = require('turf-helpers').point;\nvar bearing = require('turf-bearing');\nvar destination = require('turf-destination');\n\n/**\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the LineString.\n *\n * @name pointOnLine\n * @param {Feature<LineString>} line line to snap to\n * @param {Feature<Point>} point point to snap from\n * @return {Feature<Point>} closest point on the `line` to `point`\n * @example\n * var line = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [\n *       [-77.031669, 38.878605],\n *       [-77.029609, 38.881946],\n *       [-77.020339, 38.884084],\n *       [-77.025661, 38.885821],\n *       [-77.021884, 38.889563],\n *       [-77.019824, 38.892368]\n *     ]\n *   }\n * };\n * var pt = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-77.037076, 38.884017]\n *   }\n * };\n *\n * var snapped = turf.pointOnLine(line, pt);\n * snapped.properties['marker-color'] = '#00f'\n *\n * var result = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": [line, pt, snapped]\n * };\n *\n * //=result\n */\n\nmodule.exports = function (line, pt) {\n    var coords;\n    if (line.type === 'Feature') {\n        coords = line.geometry.coordinates;\n    } else if (line.type === 'LineString') {\n        coords = line.coordinates;\n    } else {\n        throw new Error('input must be a LineString Feature or Geometry');\n    }\n\n    return pointOnLine(pt, coords);\n};\n\nfunction pointOnLine(pt, coords) {\n    var units = 'miles';\n    var closestPt = point([Infinity, Infinity], {\n        dist: Infinity\n    });\n    for (var i = 0; i < coords.length - 1; i++) {\n        var start = point(coords[i]);\n        var stop = point(coords[i + 1]);\n        //start\n        start.properties.dist = distance(pt, start, units);\n        //stop\n        stop.properties.dist = distance(pt, stop, units);\n        //perpendicular\n        var heightDistance = Math.max(start.properties.dist, stop.properties.dist);\n        var direction = bearing(start, stop);\n        var perpendicularPt1 = destination(pt, heightDistance, direction + 90, units);\n        var perpendicularPt2 = destination(pt, heightDistance, direction - 90, units);\n        var intersect = lineIntersects(\n        perpendicularPt1.geometry.coordinates[0],\n        perpendicularPt1.geometry.coordinates[1],\n        perpendicularPt2.geometry.coordinates[0],\n        perpendicularPt2.geometry.coordinates[1],\n        start.geometry.coordinates[0],\n        start.geometry.coordinates[1],\n        stop.geometry.coordinates[0],\n        stop.geometry.coordinates[1]\n        );\n        var intersectPt;\n        if (intersect) {\n            intersectPt = point(intersect);\n            intersectPt.properties.dist = distance(pt, intersectPt, units);\n        }\n\n        if (start.properties.dist < closestPt.properties.dist) {\n            closestPt = start;\n            closestPt.properties.index = i;\n        }\n        if (stop.properties.dist < closestPt.properties.dist) {\n            closestPt = stop;\n            closestPt.properties.index = i;\n        }\n        if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n            closestPt = intersectPt;\n            closestPt.properties.index = i;\n        }\n    }\n\n    return closestPt;\n}\n\n// modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/\nfunction lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {\n    // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point\n    var denominator, a, b, numerator1, numerator2;\n    var result = {\n        x: null,\n        y: null,\n        onLine1: false,\n        onLine2: false\n    };\n    denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));\n    if (denominator === 0) {\n        if (result.x !== null && result.y !== null) {\n            return result;\n        } else {\n            return false;\n        }\n    }\n    a = line1StartY - line2StartY;\n    b = line1StartX - line2StartX;\n    numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);\n    numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);\n    a = numerator1 / denominator;\n    b = numerator2 / denominator;\n\n    // if we cast these lines infinitely in both directions, they intersect here:\n    result.x = line1StartX + (a * (line1EndX - line1StartX));\n    result.y = line1StartY + (a * (line1EndY - line1StartY));\n\n    // if line1 is a segment and line2 is infinite, they intersect if:\n    if (a > 0 && a < 1) {\n        result.onLine1 = true;\n    }\n    // if line2 is a segment and line1 is infinite, they intersect if:\n    if (b > 0 && b < 1) {\n        result.onLine2 = true;\n    }\n    // if line1 and line2 are segments, they intersect if both of the above are true\n    if (result.onLine1 && result.onLine2) {\n        return [result.x, result.y];\n    } else {\n        return false;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}