{"ast":null,"code":"var point = require('turf-helpers').point;\n\nvar featurecollection = require('turf-helpers').featureCollection;\n\nvar distance = require('turf-distance');\n/**\n * Takes a bounding box and a cell depth and returns a set of {@link Point|points} in a grid.\n *\n * @name pointGrid\n * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @param {number} cellSize the distance across each cell\n * @param {string} [units=kilometers] used in calculating cellWidth, can be degrees, radians, miles, or kilometers\n * @return {FeatureCollection<Point>} grid of points\n * @example\n * var extent = [-70.823364, -33.553984, -70.473175, -33.302986];\n * var cellWidth = 3;\n * var units = 'miles';\n *\n * var grid = turf.pointGrid(extent, cellWidth, units);\n *\n * //=grid\n */\n\n\nmodule.exports = function pointGrid(bbox, cellSize, units) {\n  var fc = featurecollection([]);\n  var xFraction = cellSize / distance(point([bbox[0], bbox[1]]), point([bbox[2], bbox[1]]), units);\n  var cellWidth = xFraction * (bbox[2] - bbox[0]);\n  var yFraction = cellSize / distance(point([bbox[0], bbox[1]]), point([bbox[0], bbox[3]]), units);\n  var cellHeight = yFraction * (bbox[3] - bbox[1]);\n  var currentX = bbox[0];\n\n  while (currentX <= bbox[2]) {\n    var currentY = bbox[1];\n\n    while (currentY <= bbox[3]) {\n      fc.features.push(point([currentX, currentY]));\n      currentY += cellHeight;\n    }\n\n    currentX += cellWidth;\n  }\n\n  return fc;\n};","map":{"version":3,"sources":["/Users/yiqianyao/workspace/something/aApace_floor_draw/node_modules/turf-point-grid/index.js"],"names":["point","require","featurecollection","featureCollection","distance","module","exports","pointGrid","bbox","cellSize","units","fc","xFraction","cellWidth","yFraction","cellHeight","currentX","currentY","features","push"],"mappings":"AAAA,IAAIA,KAAK,GAAGC,OAAO,CAAC,cAAD,CAAP,CAAwBD,KAApC;;AACA,IAAIE,iBAAiB,GAAGD,OAAO,CAAC,cAAD,CAAP,CAAwBE,iBAAhD;;AACA,IAAIC,QAAQ,GAAGH,OAAO,CAAC,eAAD,CAAtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAI,MAAM,CAACC,OAAP,GAAiB,SAASC,SAAT,CAAmBC,IAAnB,EAAyBC,QAAzB,EAAmCC,KAAnC,EAA0C;AACvD,MAAIC,EAAE,GAAGT,iBAAiB,CAAC,EAAD,CAA1B;AACA,MAAIU,SAAS,GAAGH,QAAQ,GAAIL,QAAQ,CAACJ,KAAK,CAAC,CAACQ,IAAI,CAAC,CAAD,CAAL,EAAUA,IAAI,CAAC,CAAD,CAAd,CAAD,CAAN,EAA4BR,KAAK,CAAC,CAACQ,IAAI,CAAC,CAAD,CAAL,EAAUA,IAAI,CAAC,CAAD,CAAd,CAAD,CAAjC,EAAuDE,KAAvD,CAApC;AACA,MAAIG,SAAS,GAAGD,SAAS,IAAIJ,IAAI,CAAC,CAAD,CAAJ,GAAUA,IAAI,CAAC,CAAD,CAAlB,CAAzB;AACA,MAAIM,SAAS,GAAGL,QAAQ,GAAIL,QAAQ,CAACJ,KAAK,CAAC,CAACQ,IAAI,CAAC,CAAD,CAAL,EAAUA,IAAI,CAAC,CAAD,CAAd,CAAD,CAAN,EAA4BR,KAAK,CAAC,CAACQ,IAAI,CAAC,CAAD,CAAL,EAAUA,IAAI,CAAC,CAAD,CAAd,CAAD,CAAjC,EAAuDE,KAAvD,CAApC;AACA,MAAIK,UAAU,GAAGD,SAAS,IAAIN,IAAI,CAAC,CAAD,CAAJ,GAAUA,IAAI,CAAC,CAAD,CAAlB,CAA1B;AAEA,MAAIQ,QAAQ,GAAGR,IAAI,CAAC,CAAD,CAAnB;;AACA,SAAOQ,QAAQ,IAAIR,IAAI,CAAC,CAAD,CAAvB,EAA4B;AACxB,QAAIS,QAAQ,GAAGT,IAAI,CAAC,CAAD,CAAnB;;AACA,WAAOS,QAAQ,IAAIT,IAAI,CAAC,CAAD,CAAvB,EAA4B;AACxBG,MAAAA,EAAE,CAACO,QAAH,CAAYC,IAAZ,CAAiBnB,KAAK,CAAC,CAACgB,QAAD,EAAWC,QAAX,CAAD,CAAtB;AAEAA,MAAAA,QAAQ,IAAIF,UAAZ;AACH;;AACDC,IAAAA,QAAQ,IAAIH,SAAZ;AACH;;AAED,SAAOF,EAAP;AACH,CAnBD","sourcesContent":["var point = require('turf-helpers').point;\nvar featurecollection = require('turf-helpers').featureCollection;\nvar distance = require('turf-distance');\n/**\n * Takes a bounding box and a cell depth and returns a set of {@link Point|points} in a grid.\n *\n * @name pointGrid\n * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @param {number} cellSize the distance across each cell\n * @param {string} [units=kilometers] used in calculating cellWidth, can be degrees, radians, miles, or kilometers\n * @return {FeatureCollection<Point>} grid of points\n * @example\n * var extent = [-70.823364, -33.553984, -70.473175, -33.302986];\n * var cellWidth = 3;\n * var units = 'miles';\n *\n * var grid = turf.pointGrid(extent, cellWidth, units);\n *\n * //=grid\n */\nmodule.exports = function pointGrid(bbox, cellSize, units) {\n    var fc = featurecollection([]);\n    var xFraction = cellSize / (distance(point([bbox[0], bbox[1]]), point([bbox[2], bbox[1]]), units));\n    var cellWidth = xFraction * (bbox[2] - bbox[0]);\n    var yFraction = cellSize / (distance(point([bbox[0], bbox[1]]), point([bbox[0], bbox[3]]), units));\n    var cellHeight = yFraction * (bbox[3] - bbox[1]);\n\n    var currentX = bbox[0];\n    while (currentX <= bbox[2]) {\n        var currentY = bbox[1];\n        while (currentY <= bbox[3]) {\n            fc.features.push(point([currentX, currentY]));\n\n            currentY += cellHeight;\n        }\n        currentX += cellWidth;\n    }\n\n    return fc;\n};\n"]},"metadata":{},"sourceType":"script"}