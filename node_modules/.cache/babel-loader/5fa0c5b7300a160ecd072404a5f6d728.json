{"ast":null,"code":"var linestring = require('turf-helpers').lineString;\n\nvar pointOnLine = require('turf-point-on-line');\n/**\n * Takes a {@link LineString|line}, a start {@link Point}, and a stop point\n * and returns a subsection of the line in-between those points.\n * The start & stop points don't need to fall exactly on the line.\n *\n * This can be useful for extracting only the part of a route between waypoints.\n *\n * @name lineSlice\n * @param {Feature<Point>} point1 starting point\n * @param {Feature<Point>} point2 stopping point\n * @param {Feature<LineString>|LineString} line line to slice\n * @return {Feature<LineString>} sliced line\n * @example\n * var line = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [\n *       [-77.031669, 38.878605],\n *       [-77.029609, 38.881946],\n *       [-77.020339, 38.884084],\n *       [-77.025661, 38.885821],\n *       [-77.021884, 38.889563],\n *       [-77.019824, 38.892368]\n *     ]\n *   }\n * };\n * var start = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-77.029609, 38.881946]\n *   }\n * };\n * var stop = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-77.021884, 38.889563]\n *   }\n * };\n *\n * var sliced = turf.lineSlice(start, stop, line);\n *\n * //=line\n *\n * //=sliced\n */\n\n\nmodule.exports = function lineSlice(startPt, stopPt, line) {\n  var coords;\n\n  if (line.type === 'Feature') {\n    coords = line.geometry.coordinates;\n  } else if (line.type === 'LineString') {\n    coords = line.coordinates;\n  } else {\n    throw new Error('input must be a LineString Feature or Geometry');\n  }\n\n  var startVertex = pointOnLine(line, startPt);\n  var stopVertex = pointOnLine(line, stopPt);\n  var ends;\n\n  if (startVertex.properties.index <= stopVertex.properties.index) {\n    ends = [startVertex, stopVertex];\n  } else {\n    ends = [stopVertex, startVertex];\n  }\n\n  var clipLine = linestring([ends[0].geometry.coordinates], {});\n\n  for (var i = ends[0].properties.index + 1; i < ends[1].properties.index + 1; i++) {\n    clipLine.geometry.coordinates.push(coords[i]);\n  }\n\n  clipLine.geometry.coordinates.push(ends[1].geometry.coordinates);\n  return clipLine;\n};","map":{"version":3,"sources":["/Users/yiqianyao/workspace/something/aApace_floor_draw/node_modules/turf-line-slice/index.js"],"names":["linestring","require","lineString","pointOnLine","module","exports","lineSlice","startPt","stopPt","line","coords","type","geometry","coordinates","Error","startVertex","stopVertex","ends","properties","index","clipLine","i","push"],"mappings":"AAAA,IAAIA,UAAU,GAAGC,OAAO,CAAC,cAAD,CAAP,CAAwBC,UAAzC;;AACA,IAAIC,WAAW,GAAGF,OAAO,CAAC,oBAAD,CAAzB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEAG,MAAM,CAACC,OAAP,GAAiB,SAASC,SAAT,CAAmBC,OAAnB,EAA4BC,MAA5B,EAAoCC,IAApC,EAA0C;AACvD,MAAIC,MAAJ;;AACA,MAAID,IAAI,CAACE,IAAL,KAAc,SAAlB,EAA6B;AACzBD,IAAAA,MAAM,GAAGD,IAAI,CAACG,QAAL,CAAcC,WAAvB;AACH,GAFD,MAEO,IAAIJ,IAAI,CAACE,IAAL,KAAc,YAAlB,EAAgC;AACnCD,IAAAA,MAAM,GAAGD,IAAI,CAACI,WAAd;AACH,GAFM,MAEA;AACH,UAAM,IAAIC,KAAJ,CAAU,gDAAV,CAAN;AACH;;AAED,MAAIC,WAAW,GAAGZ,WAAW,CAACM,IAAD,EAAOF,OAAP,CAA7B;AACA,MAAIS,UAAU,GAAGb,WAAW,CAACM,IAAD,EAAOD,MAAP,CAA5B;AACA,MAAIS,IAAJ;;AACA,MAAIF,WAAW,CAACG,UAAZ,CAAuBC,KAAvB,IAAgCH,UAAU,CAACE,UAAX,CAAsBC,KAA1D,EAAiE;AAC7DF,IAAAA,IAAI,GAAG,CAACF,WAAD,EAAcC,UAAd,CAAP;AACH,GAFD,MAEO;AACHC,IAAAA,IAAI,GAAG,CAACD,UAAD,EAAaD,WAAb,CAAP;AACH;;AACD,MAAIK,QAAQ,GAAGpB,UAAU,CAAC,CAACiB,IAAI,CAAC,CAAD,CAAJ,CAAQL,QAAR,CAAiBC,WAAlB,CAAD,EAAiC,EAAjC,CAAzB;;AACA,OAAK,IAAIQ,CAAC,GAAGJ,IAAI,CAAC,CAAD,CAAJ,CAAQC,UAAR,CAAmBC,KAAnB,GAA2B,CAAxC,EAA2CE,CAAC,GAAGJ,IAAI,CAAC,CAAD,CAAJ,CAAQC,UAAR,CAAmBC,KAAnB,GAA2B,CAA1E,EAA6EE,CAAC,EAA9E,EAAkF;AAC9ED,IAAAA,QAAQ,CAACR,QAAT,CAAkBC,WAAlB,CAA8BS,IAA9B,CAAmCZ,MAAM,CAACW,CAAD,CAAzC;AACH;;AACDD,EAAAA,QAAQ,CAACR,QAAT,CAAkBC,WAAlB,CAA8BS,IAA9B,CAAmCL,IAAI,CAAC,CAAD,CAAJ,CAAQL,QAAR,CAAiBC,WAApD;AACA,SAAOO,QAAP;AACH,CAxBD","sourcesContent":["var linestring = require('turf-helpers').lineString;\nvar pointOnLine = require('turf-point-on-line');\n\n/**\n * Takes a {@link LineString|line}, a start {@link Point}, and a stop point\n * and returns a subsection of the line in-between those points.\n * The start & stop points don't need to fall exactly on the line.\n *\n * This can be useful for extracting only the part of a route between waypoints.\n *\n * @name lineSlice\n * @param {Feature<Point>} point1 starting point\n * @param {Feature<Point>} point2 stopping point\n * @param {Feature<LineString>|LineString} line line to slice\n * @return {Feature<LineString>} sliced line\n * @example\n * var line = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [\n *       [-77.031669, 38.878605],\n *       [-77.029609, 38.881946],\n *       [-77.020339, 38.884084],\n *       [-77.025661, 38.885821],\n *       [-77.021884, 38.889563],\n *       [-77.019824, 38.892368]\n *     ]\n *   }\n * };\n * var start = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-77.029609, 38.881946]\n *   }\n * };\n * var stop = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [-77.021884, 38.889563]\n *   }\n * };\n *\n * var sliced = turf.lineSlice(start, stop, line);\n *\n * //=line\n *\n * //=sliced\n */\n\nmodule.exports = function lineSlice(startPt, stopPt, line) {\n    var coords;\n    if (line.type === 'Feature') {\n        coords = line.geometry.coordinates;\n    } else if (line.type === 'LineString') {\n        coords = line.coordinates;\n    } else {\n        throw new Error('input must be a LineString Feature or Geometry');\n    }\n\n    var startVertex = pointOnLine(line, startPt);\n    var stopVertex = pointOnLine(line, stopPt);\n    var ends;\n    if (startVertex.properties.index <= stopVertex.properties.index) {\n        ends = [startVertex, stopVertex];\n    } else {\n        ends = [stopVertex, startVertex];\n    }\n    var clipLine = linestring([ends[0].geometry.coordinates], {});\n    for (var i = ends[0].properties.index + 1; i < ends[1].properties.index + 1; i++) {\n        clipLine.geometry.coordinates.push(coords[i]);\n    }\n    clipLine.geometry.coordinates.push(ends[1].geometry.coordinates);\n    return clipLine;\n};\n"]},"metadata":{},"sourceType":"script"}