{"ast":null,"code":"/**\n * Iterate over coordinates in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (value)\n * @param {boolean=} excludeWrapCoord whether or not to include\n * the final coordinate of LinearRings that wraps the ring in its iteration.\n * @example\n * var point = { type: 'Point', coordinates: [0, 0] };\n * coordEach(point, function(coords) {\n *   // coords is equal to [0, 0]\n * });\n */\nfunction coordEach(layer, callback, excludeWrapCoord) {\n  var i,\n      j,\n      k,\n      g,\n      l,\n      geometry,\n      stopG,\n      coords,\n      geometryMaybeCollection,\n      wrapShrink = 0,\n      isGeometryCollection,\n      isFeatureCollection = layer.type === 'FeatureCollection',\n      isFeature = layer.type === 'Feature',\n      stop = isFeatureCollection ? layer.features.length : 1; // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection ? layer.features[i].geometry : isFeature ? layer.geometry : layer;\n    isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';\n    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n      coords = geometry.coordinates;\n      wrapShrink = excludeWrapCoord && (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon') ? 1 : 0;\n\n      if (geometry.type === 'Point') {\n        callback(coords);\n      } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {\n        for (j = 0; j < coords.length; j++) callback(coords[j]);\n      } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {\n        for (j = 0; j < coords.length; j++) for (k = 0; k < coords[j].length - wrapShrink; k++) callback(coords[j][k]);\n      } else if (geometry.type === 'MultiPolygon') {\n        for (j = 0; j < coords.length; j++) for (k = 0; k < coords[j].length; k++) for (l = 0; l < coords[j][k].length - wrapShrink; l++) callback(coords[j][k][l]);\n      } else {\n        throw new Error('Unknown Geometry Type');\n      }\n    }\n  }\n}\n\nmodule.exports.coordEach = coordEach;\n/**\n * Reduce coordinates in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all coordinates is unnecessary.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (memo, value) and returns\n * a new memo\n * @param {*} memo the starting value of memo: can be any type.\n * @param {boolean=} excludeWrapCoord whether or not to include\n * the final coordinate of LinearRings that wraps the ring in its iteration.\n * @return {*} combined value\n */\n\nfunction coordReduce(layer, callback, memo, excludeWrapCoord) {\n  coordEach(layer, function (coord) {\n    memo = callback(memo, coord);\n  }, excludeWrapCoord);\n  return memo;\n}\n\nmodule.exports.coordReduce = coordReduce;\n/**\n * Iterate over property objects in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (value)\n * @example\n * var point = { type: 'Feature', geometry: null, properties: { foo: 1 } };\n * propEach(point, function(props) {\n *   // props is equal to { foo: 1}\n * });\n */\n\nfunction propEach(layer, callback) {\n  var i;\n\n  switch (layer.type) {\n    case 'FeatureCollection':\n      for (i = 0; i < layer.features.length; i++) {\n        callback(layer.features[i].properties);\n      }\n\n      break;\n\n    case 'Feature':\n      callback(layer.properties);\n      break;\n  }\n}\n\nmodule.exports.propEach = propEach;\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (memo, coord) and returns\n * a new memo\n * @param {*} memo the starting value of memo: can be any type.\n * @return {*} combined value\n */\n\nfunction propReduce(layer, callback, memo) {\n  propEach(layer, function (prop) {\n    memo = callback(memo, prop);\n  });\n  return memo;\n}\n\nmodule.exports.propReduce = propReduce;\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (value)\n * @example\n * var feature = { type: 'Feature', geometry: null, properties: {} };\n * featureEach(feature, function(feature) {\n *   // feature == feature\n * });\n */\n\nfunction featureEach(layer, callback) {\n  if (layer.type === 'Feature') {\n    callback(layer);\n  } else if (layer.type === 'FeatureCollection') {\n    for (var i = 0; i < layer.features.length; i++) {\n      callback(layer.features[i]);\n    }\n  }\n}\n\nmodule.exports.featureEach = featureEach;\n/**\n * Get all coordinates from any GeoJSON object, returning an array of coordinate\n * arrays.\n * @param {Object} layer any GeoJSON object\n * @return {Array<Array<Number>>} coordinate position array\n */\n\nfunction coordAll(layer) {\n  var coords = [];\n  coordEach(layer, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\nmodule.exports.coordAll = coordAll;","map":{"version":3,"sources":["/Users/yiqianyao/workspace/something/aApace_floor_draw/node_modules/turf-meta/index.js"],"names":["coordEach","layer","callback","excludeWrapCoord","i","j","k","g","l","geometry","stopG","coords","geometryMaybeCollection","wrapShrink","isGeometryCollection","isFeatureCollection","type","isFeature","stop","features","length","geometries","coordinates","Error","module","exports","coordReduce","memo","coord","propEach","properties","propReduce","prop","featureEach","coordAll","push"],"mappings":"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","sourcesContent":["/**\n * Iterate over coordinates in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (value)\n * @param {boolean=} excludeWrapCoord whether or not to include\n * the final coordinate of LinearRings that wraps the ring in its iteration.\n * @example\n * var point = { type: 'Point', coordinates: [0, 0] };\n * coordEach(point, function(coords) {\n *   // coords is equal to [0, 0]\n * });\n */\nfunction coordEach(layer, callback, excludeWrapCoord) {\n    var i, j, k, g, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        isGeometryCollection,\n        isFeatureCollection = layer.type === 'FeatureCollection',\n        isFeature = layer.type === 'Feature',\n        stop = isFeatureCollection ? layer.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? layer.features[i].geometry :\n        (isFeature ? layer.geometry : layer));\n        isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n            geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n            coords = geometry.coordinates;\n\n            wrapShrink = (excludeWrapCoord &&\n                (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon')) ?\n                1 : 0;\n\n            if (geometry.type === 'Point') {\n                callback(coords);\n            } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {\n                for (j = 0; j < coords.length; j++) callback(coords[j]);\n            } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {\n                for (j = 0; j < coords.length; j++)\n                    for (k = 0; k < coords[j].length - wrapShrink; k++)\n                        callback(coords[j][k]);\n            } else if (geometry.type === 'MultiPolygon') {\n                for (j = 0; j < coords.length; j++)\n                    for (k = 0; k < coords[j].length; k++)\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++)\n                            callback(coords[j][k][l]);\n            } else {\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\nmodule.exports.coordEach = coordEach;\n\n/**\n * Reduce coordinates in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all coordinates is unnecessary.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (memo, value) and returns\n * a new memo\n * @param {*} memo the starting value of memo: can be any type.\n * @param {boolean=} excludeWrapCoord whether or not to include\n * the final coordinate of LinearRings that wraps the ring in its iteration.\n * @return {*} combined value\n */\nfunction coordReduce(layer, callback, memo, excludeWrapCoord) {\n    coordEach(layer, function (coord) {\n        memo = callback(memo, coord);\n    }, excludeWrapCoord);\n    return memo;\n}\nmodule.exports.coordReduce = coordReduce;\n\n/**\n * Iterate over property objects in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (value)\n * @example\n * var point = { type: 'Feature', geometry: null, properties: { foo: 1 } };\n * propEach(point, function(props) {\n *   // props is equal to { foo: 1}\n * });\n */\nfunction propEach(layer, callback) {\n    var i;\n    switch (layer.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < layer.features.length; i++) {\n            callback(layer.features[i].properties);\n        }\n        break;\n    case 'Feature':\n        callback(layer.properties);\n        break;\n    }\n}\nmodule.exports.propEach = propEach;\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (memo, coord) and returns\n * a new memo\n * @param {*} memo the starting value of memo: can be any type.\n * @return {*} combined value\n */\nfunction propReduce(layer, callback, memo) {\n    propEach(layer, function (prop) {\n        memo = callback(memo, prop);\n    });\n    return memo;\n}\nmodule.exports.propReduce = propReduce;\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @param {Object} layer any GeoJSON object\n * @param {Function} callback a method that takes (value)\n * @example\n * var feature = { type: 'Feature', geometry: null, properties: {} };\n * featureEach(feature, function(feature) {\n *   // feature == feature\n * });\n */\nfunction featureEach(layer, callback) {\n    if (layer.type === 'Feature') {\n        callback(layer);\n    } else if (layer.type === 'FeatureCollection') {\n        for (var i = 0; i < layer.features.length; i++) {\n            callback(layer.features[i]);\n        }\n    }\n}\nmodule.exports.featureEach = featureEach;\n\n/**\n * Get all coordinates from any GeoJSON object, returning an array of coordinate\n * arrays.\n * @param {Object} layer any GeoJSON object\n * @return {Array<Array<Number>>} coordinate position array\n */\nfunction coordAll(layer) {\n    var coords = [];\n    coordEach(layer, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\nmodule.exports.coordAll = coordAll;\n"]},"metadata":{},"sourceType":"script"}