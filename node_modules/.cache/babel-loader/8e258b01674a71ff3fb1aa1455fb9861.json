{"ast":null,"code":"/* eslint-disable */\n\n/*\n * Copyright (c) 2010, Jason Davies.\n *\n * All rights reserved.  This code is based on Bradley White's Java version,\n * which is in turn based on Nicholas Yue's C++ version, which in turn is based\n * on Paul D. Bourke's original Fortran version.  See below for the respective\n * copyright notices.\n *\n * See http://local.wasp.uwa.edu.au/~pbourke/papers/conrec/ for the original\n * paper by Paul D. Bourke.\n *\n * The vector conversion code is based on http://apptree.net/conrec.htm by\n * Graham Cox.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of the <organization> nor the\n *       names of its contributors may be used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * Copyright (c) 1996-1997 Nicholas Yue\n *\n * This software is copyrighted by Nicholas Yue. This code is based on Paul D.\n * Bourke's CONREC.F routine.\n *\n * The authors hereby grant permission to use, copy, and distribute this\n * software and its documentation for any purpose, provided that existing\n * copyright notices are retained in all copies and that this notice is\n * included verbatim in any distributions. Additionally, the authors grant\n * permission to modify this software and its documentation for any purpose,\n * provided that such modifications are not distributed without the explicit\n * consent of the authors and that existing copyright notices are retained in\n * all copies. Some of the algorithms implemented by this software are\n * patented, observe all applicable patent law.\n *\n * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\n * OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES THEREOF,\n * EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE IS\n * PROVIDED ON AN \"AS IS\" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE NO\n * OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR\n * MODIFICATIONS.\n */\nmodule.exports = Conrec;\nvar EPSILON = 1e-10;\n\nfunction pointsEqual(a, b) {\n  var x = a.x - b.x,\n      y = a.y - b.y;\n  return x * x + y * y < EPSILON;\n}\n\nfunction reverseList(list) {\n  var pp = list.head;\n\n  while (pp) {\n    // swap prev/next pointers\n    var temp = pp.next;\n    pp.next = pp.prev;\n    pp.prev = temp; // continue through the list\n\n    pp = temp;\n  } // swap head/tail pointers\n\n\n  var temp = list.head;\n  list.head = list.tail;\n  list.tail = temp;\n}\n\nfunction ContourBuilder(level) {\n  this.level = level;\n  this.s = null;\n  this.count = 0;\n}\n\nContourBuilder.prototype.remove_seq = function (list) {\n  // if list is the first item, static ptr s is updated\n  if (list.prev) {\n    list.prev.next = list.next;\n  } else {\n    this.s = list.next;\n  }\n\n  if (list.next) {\n    list.next.prev = list.prev;\n  }\n\n  --this.count;\n};\n\nContourBuilder.prototype.addSegment = function (a, b) {\n  var ss = this.s;\n  var ma = null;\n  var mb = null;\n  var prependA = false;\n  var prependB = false;\n\n  while (ss) {\n    if (ma == null) {\n      // no match for a yet\n      if (pointsEqual(a, ss.head.p)) {\n        ma = ss;\n        prependA = true;\n      } else if (pointsEqual(a, ss.tail.p)) {\n        ma = ss;\n      }\n    }\n\n    if (mb == null) {\n      // no match for b yet\n      if (pointsEqual(b, ss.head.p)) {\n        mb = ss;\n        prependB = true;\n      } else if (pointsEqual(b, ss.tail.p)) {\n        mb = ss;\n      }\n    } // if we matched both no need to continue searching\n\n\n    if (mb != null && ma != null) {\n      break;\n    } else {\n      ss = ss.next;\n    }\n  } // c is the case selector based on which of ma and/or mb are set\n\n\n  var c = (ma != null ? 1 : 0) | (mb != null ? 2 : 0);\n\n  switch (c) {\n    case 0:\n      // both unmatched, add as new sequence\n      var aa = {\n        p: a,\n        prev: null\n      };\n      var bb = {\n        p: b,\n        next: null\n      };\n      aa.next = bb;\n      bb.prev = aa; // create sequence element and push onto head of main list. The order\n      // of items in this list is unimportant\n\n      ma = {\n        head: aa,\n        tail: bb,\n        next: this.s,\n        prev: null,\n        closed: false\n      };\n\n      if (this.s) {\n        this.s.prev = ma;\n      }\n\n      this.s = ma;\n      ++this.count; // not essential - tracks number of unmerged sequences\n\n      break;\n\n    case 1:\n      // a matched, b did not - thus b extends sequence ma\n      var pp = {\n        p: b\n      };\n\n      if (prependA) {\n        pp.next = ma.head;\n        pp.prev = null;\n        ma.head.prev = pp;\n        ma.head = pp;\n      } else {\n        pp.next = null;\n        pp.prev = ma.tail;\n        ma.tail.next = pp;\n        ma.tail = pp;\n      }\n\n      break;\n\n    case 2:\n      // b matched, a did not - thus a extends sequence mb\n      var pp = {\n        p: a\n      };\n\n      if (prependB) {\n        pp.next = mb.head;\n        pp.prev = null;\n        mb.head.prev = pp;\n        mb.head = pp;\n      } else {\n        pp.next = null;\n        pp.prev = mb.tail;\n        mb.tail.next = pp;\n        mb.tail = pp;\n      }\n\n      break;\n\n    case 3:\n      // both matched, can merge sequences\n      // if the sequences are the same, do nothing, as we are simply closing this path (could set a flag)\n      if (ma === mb) {\n        var pp = {\n          p: ma.tail.p,\n          next: ma.head,\n          prev: null\n        };\n        ma.head.prev = pp;\n        ma.head = pp;\n        ma.closed = true;\n        break;\n      } // there are 4 ways the sequence pair can be joined. The current setting of prependA and\n      // prependB will tell us which type of join is needed. For head/head and tail/tail joins\n      // one sequence needs to be reversed\n\n\n      switch ((prependA ? 1 : 0) | (prependB ? 2 : 0)) {\n        case 0:\n          // tail-tail\n          // reverse ma and append to mb\n          reverseList(ma);\n        // fall through to head/tail case\n\n        case 1:\n          // head-tail\n          // ma is appended to mb and ma discarded\n          mb.tail.next = ma.head;\n          ma.head.prev = mb.tail;\n          mb.tail = ma.tail; //discard ma sequence record\n\n          this.remove_seq(ma);\n          break;\n\n        case 3:\n          // head-head\n          // reverse ma and append mb to it\n          reverseList(ma);\n        // fall through to tail/head case\n\n        case 2:\n          // tail-head\n          // mb is appended to ma and mb is discarded\n          ma.tail.next = mb.head;\n          mb.head.prev = ma.tail;\n          ma.tail = mb.tail; //discard mb sequence record\n\n          this.remove_seq(mb);\n          break;\n      }\n\n  }\n};\n/*\n * Implements CONREC.\n *\n * @private\n * @param {function} drawContour function for drawing contour.  Defaults to a\n *                               custom \"contour builder\", which populates the\n *                               contours property.\n */\n\n\nfunction Conrec(drawContour) {\n  if (!drawContour) {\n    var c = this;\n    c.contours = {};\n    /**\n     * drawContour - interface for implementing the user supplied method to\n     * render the countours.\n     *\n     * Draws a line between the start and end coordinates.\n     *\n     * @private\n     * @param startX    - start coordinate for X\n     * @param startY    - start coordinate for Y\n     * @param endX      - end coordinate for X\n     * @param endY      - end coordinate for Y\n     * @param contourLevel - Contour level for line.\n     */\n\n    this.drawContour = function (startX, startY, endX, endY, contourLevel, k) {\n      var cb = c.contours[k];\n\n      if (!cb) {\n        cb = c.contours[k] = new ContourBuilder(contourLevel);\n      }\n\n      cb.addSegment({\n        x: startX,\n        y: startY\n      }, {\n        x: endX,\n        y: endY\n      });\n    };\n\n    this.contourList = function () {\n      var l = [];\n      var a = c.contours;\n\n      for (var k in a) {\n        var s = a[k].s;\n        var level = a[k].level;\n\n        while (s) {\n          var h = s.head;\n          var l2 = [];\n          l2.level = level;\n          l2.k = k;\n\n          while (h && h.p) {\n            l2.push(h.p);\n            h = h.next;\n          }\n\n          l.push(l2);\n          s = s.next;\n        }\n      }\n\n      l.sort(function (a, b) {\n        return a.k - b.k;\n      });\n      return l;\n    };\n  } else {\n    this.drawContour = drawContour;\n  }\n\n  this.h = new Array(5);\n  this.sh = new Array(5);\n  this.xh = new Array(5);\n  this.yh = new Array(5);\n}\n/*\n * contour is a contouring subroutine for rectangularily spaced data\n *\n * It emits calls to a line drawing subroutine supplied by the user which\n * draws a contour map corresponding to real*4data on a randomly spaced\n * rectangular grid. The coordinates emitted are in the same units given in\n * the x() and y() arrays.\n *\n * Any number of contour levels may be specified but they must be in order of\n * increasing value.\n *\n *\n * @param {number[][]} d - matrix of data to contour\n * @param {number} ilb,iub,jlb,jub - index bounds of data matrix\n *\n *             The following two, one dimensional arrays (x and y) contain\n *             the horizontal and vertical coordinates of each sample points.\n * @param {number[]} x  - data matrix column coordinates\n * @param {number[]} y  - data matrix row coordinates\n * @param {number} nc   - number of contour levels\n * @param {number[]} z  - contour levels in increasing order.\n */\n\n\nConrec.prototype.contour = function (d, ilb, iub, jlb, jub, x, y, nc, z) {\n  var h = this.h,\n      sh = this.sh,\n      xh = this.xh,\n      yh = this.yh;\n  var drawContour = this.drawContour;\n  this.contours = {};\n\n  var xsect = function (p1, p2) {\n    return (h[p2] * xh[p1] - h[p1] * xh[p2]) / (h[p2] - h[p1]);\n  };\n\n  var ysect = function (p1, p2) {\n    return (h[p2] * yh[p1] - h[p1] * yh[p2]) / (h[p2] - h[p1]);\n  };\n\n  var m1;\n  var m2;\n  var m3;\n  var case_value;\n  var dmin;\n  var dmax;\n  var x1 = 0.0;\n  var x2 = 0.0;\n  var y1 = 0.0;\n  var y2 = 0.0; // The indexing of im and jm should be noted as it has to start from zero\n  // unlike the fortran counter part\n\n  var im = [0, 1, 1, 0];\n  var jm = [0, 0, 1, 1]; // Note that castab is arranged differently from the FORTRAN code because\n  // Fortran and C/C++ arrays are transposed of each other, in this case\n  // it is more tricky as castab is in 3 dimensions\n\n  var castab = [[[0, 0, 8], [0, 2, 5], [7, 6, 9]], [[0, 3, 4], [1, 3, 1], [4, 3, 0]], [[9, 6, 7], [5, 2, 0], [8, 0, 0]]];\n\n  for (var j = jub - 1; j >= jlb; j--) {\n    for (var i = ilb; i <= iub - 1; i++) {\n      var temp1, temp2;\n      temp1 = Math.min(d[i][j], d[i][j + 1]);\n      temp2 = Math.min(d[i + 1][j], d[i + 1][j + 1]);\n      dmin = Math.min(temp1, temp2);\n      temp1 = Math.max(d[i][j], d[i][j + 1]);\n      temp2 = Math.max(d[i + 1][j], d[i + 1][j + 1]);\n      dmax = Math.max(temp1, temp2);\n\n      if (dmax >= z[0] && dmin <= z[nc - 1]) {\n        for (var k = 0; k < nc; k++) {\n          if (z[k] >= dmin && z[k] <= dmax) {\n            for (var m = 4; m >= 0; m--) {\n              if (m > 0) {\n                // The indexing of im and jm should be noted as it has to\n                // start from zero\n                h[m] = d[i + im[m - 1]][j + jm[m - 1]] - z[k];\n                xh[m] = x[i + im[m - 1]];\n                yh[m] = y[j + jm[m - 1]];\n              } else {\n                h[0] = 0.25 * (h[1] + h[2] + h[3] + h[4]);\n                xh[0] = 0.5 * (x[i] + x[i + 1]);\n                yh[0] = 0.5 * (y[j] + y[j + 1]);\n              }\n\n              if (h[m] > EPSILON) {\n                sh[m] = 1;\n              } else if (h[m] < -EPSILON) {\n                sh[m] = -1;\n              } else sh[m] = 0;\n            } //\n            // Note: at this stage the relative heights of the corners and the\n            // centre are in the h array, and the corresponding coordinates are\n            // in the xh and yh arrays. The centre of the box is indexed by 0\n            // and the 4 corners by 1 to 4 as shown below.\n            // Each triangle is then indexed by the parameter m, and the 3\n            // vertices of each triangle are indexed by parameters m1,m2,and\n            // m3.\n            // It is assumed that the centre of the box is always vertex 2\n            // though this isimportant only when all 3 vertices lie exactly on\n            // the same contour level, in which case only the side of the box\n            // is drawn.\n            //\n            //\n            //      vertex 4 +-------------------+ vertex 3\n            //               | \\               / |\n            //               |   \\    m-3    /   |\n            //               |     \\       /     |\n            //               |       \\   /       |\n            //               |  m=2    X   m=2   |       the centre is vertex 0\n            //               |       /   \\       |\n            //               |     /       \\     |\n            //               |   /    m=1    \\   |\n            //               | /               \\ |\n            //      vertex 1 +-------------------+ vertex 2\n            //\n            //\n            //\n            //               Scan each triangle in the box\n            //\n\n\n            for (m = 1; m <= 4; m++) {\n              m1 = m;\n              m2 = 0;\n\n              if (m != 4) {\n                m3 = m + 1;\n              } else {\n                m3 = 1;\n              }\n\n              case_value = castab[sh[m1] + 1][sh[m2] + 1][sh[m3] + 1];\n\n              if (case_value != 0) {\n                switch (case_value) {\n                  case 1:\n                    // Line between vertices 1 and 2\n                    x1 = xh[m1];\n                    y1 = yh[m1];\n                    x2 = xh[m2];\n                    y2 = yh[m2];\n                    break;\n\n                  case 2:\n                    // Line between vertices 2 and 3\n                    x1 = xh[m2];\n                    y1 = yh[m2];\n                    x2 = xh[m3];\n                    y2 = yh[m3];\n                    break;\n\n                  case 3:\n                    // Line between vertices 3 and 1\n                    x1 = xh[m3];\n                    y1 = yh[m3];\n                    x2 = xh[m1];\n                    y2 = yh[m1];\n                    break;\n\n                  case 4:\n                    // Line between vertex 1 and side 2-3\n                    x1 = xh[m1];\n                    y1 = yh[m1];\n                    x2 = xsect(m2, m3);\n                    y2 = ysect(m2, m3);\n                    break;\n\n                  case 5:\n                    // Line between vertex 2 and side 3-1\n                    x1 = xh[m2];\n                    y1 = yh[m2];\n                    x2 = xsect(m3, m1);\n                    y2 = ysect(m3, m1);\n                    break;\n\n                  case 6:\n                    //  Line between vertex 3 and side 1-2\n                    x1 = xh[m3];\n                    y1 = yh[m3];\n                    x2 = xsect(m1, m2);\n                    y2 = ysect(m1, m2);\n                    break;\n\n                  case 7:\n                    // Line between sides 1-2 and 2-3\n                    x1 = xsect(m1, m2);\n                    y1 = ysect(m1, m2);\n                    x2 = xsect(m2, m3);\n                    y2 = ysect(m2, m3);\n                    break;\n\n                  case 8:\n                    // Line between sides 2-3 and 3-1\n                    x1 = xsect(m2, m3);\n                    y1 = ysect(m2, m3);\n                    x2 = xsect(m3, m1);\n                    y2 = ysect(m3, m1);\n                    break;\n\n                  case 9:\n                    // Line between sides 3-1 and 1-2\n                    x1 = xsect(m3, m1);\n                    y1 = ysect(m3, m1);\n                    x2 = xsect(m1, m2);\n                    y2 = ysect(m1, m2);\n                    break;\n\n                  default:\n                    break;\n                } // Put your processing code here and comment out the printf\n                //printf(\"%f %f %f %f %f\\n\",x1,y1,x2,y2,z[k]);\n\n\n                drawContour(x1, y1, x2, y2, z[k], k);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};","map":{"version":3,"sources":["/Users/yiqianyao/workspace/something/floorcanvas/node_modules/turf-isolines/conrec.js"],"names":["module","exports","Conrec","EPSILON","pointsEqual","a","b","x","y","reverseList","list","pp","head","temp","next","prev","tail","ContourBuilder","level","s","count","prototype","remove_seq","addSegment","ss","ma","mb","prependA","prependB","p","c","aa","bb","closed","drawContour","contours","startX","startY","endX","endY","contourLevel","k","cb","contourList","l","h","l2","push","sort","Array","sh","xh","yh","contour","d","ilb","iub","jlb","jub","nc","z","xsect","p1","p2","ysect","m1","m2","m3","case_value","dmin","dmax","x1","x2","y1","y2","im","jm","castab","j","i","temp1","temp2","Math","min","max","m"],"mappings":"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","sourcesContent":["/* eslint-disable */\n\n/*\n * Copyright (c) 2010, Jason Davies.\n *\n * All rights reserved.  This code is based on Bradley White's Java version,\n * which is in turn based on Nicholas Yue's C++ version, which in turn is based\n * on Paul D. Bourke's original Fortran version.  See below for the respective\n * copyright notices.\n *\n * See http://local.wasp.uwa.edu.au/~pbourke/papers/conrec/ for the original\n * paper by Paul D. Bourke.\n *\n * The vector conversion code is based on http://apptree.net/conrec.htm by\n * Graham Cox.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of the <organization> nor the\n *       names of its contributors may be used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * Copyright (c) 1996-1997 Nicholas Yue\n *\n * This software is copyrighted by Nicholas Yue. This code is based on Paul D.\n * Bourke's CONREC.F routine.\n *\n * The authors hereby grant permission to use, copy, and distribute this\n * software and its documentation for any purpose, provided that existing\n * copyright notices are retained in all copies and that this notice is\n * included verbatim in any distributions. Additionally, the authors grant\n * permission to modify this software and its documentation for any purpose,\n * provided that such modifications are not distributed without the explicit\n * consent of the authors and that existing copyright notices are retained in\n * all copies. Some of the algorithms implemented by this software are\n * patented, observe all applicable patent law.\n *\n * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\n * OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES THEREOF,\n * EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE IS\n * PROVIDED ON AN \"AS IS\" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE NO\n * OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR\n * MODIFICATIONS.\n */\n\n\n  module.exports = Conrec;\n\n  var EPSILON = 1e-10;\n\n  function pointsEqual(a, b) {\n      var x = a.x - b.x, y = a.y - b.y;\n      return x * x + y * y < EPSILON;\n  }\n\n  function reverseList(list) {\n      var pp = list.head;\n\n      while (pp) {\n      // swap prev/next pointers\n          var temp = pp.next;\n          pp.next = pp.prev;\n          pp.prev = temp;\n\n      // continue through the list\n          pp = temp;\n      }\n\n    // swap head/tail pointers\n      var temp = list.head;\n      list.head = list.tail;\n      list.tail = temp;\n  }\n\n  function ContourBuilder(level) {\n      this.level = level;\n      this.s = null;\n      this.count = 0;\n  }\n  ContourBuilder.prototype.remove_seq = function (list) {\n    // if list is the first item, static ptr s is updated\n      if (list.prev) {\n          list.prev.next = list.next;\n      } else {\n          this.s = list.next;\n      }\n\n      if (list.next) {\n          list.next.prev = list.prev;\n      }\n      --this.count;\n  };\n  ContourBuilder.prototype.addSegment = function (a, b) {\n      var ss = this.s;\n      var ma = null;\n      var mb = null;\n      var prependA = false;\n      var prependB = false;\n\n      while (ss) {\n          if (ma == null) {\n        // no match for a yet\n              if (pointsEqual(a, ss.head.p)) {\n                  ma = ss;\n                  prependA = true;\n              } else if (pointsEqual(a, ss.tail.p)) {\n                  ma = ss;\n              }\n          }\n          if (mb == null) {\n        // no match for b yet\n              if (pointsEqual(b, ss.head.p)) {\n                  mb = ss;\n                  prependB = true;\n              } else if (pointsEqual(b, ss.tail.p)) {\n                  mb = ss;\n              }\n          }\n      // if we matched both no need to continue searching\n          if (mb != null && ma != null) {\n              break;\n          } else {\n              ss = ss.next;\n          }\n      }\n\n    // c is the case selector based on which of ma and/or mb are set\n      var c = ((ma != null) ? 1 : 0) | ((mb != null) ? 2 : 0);\n\n      switch (c) {\n      case 0:   // both unmatched, add as new sequence\n          var aa = {p: a, prev: null};\n          var bb = {p: b, next: null};\n          aa.next = bb;\n          bb.prev = aa;\n\n        // create sequence element and push onto head of main list. The order\n        // of items in this list is unimportant\n          ma = {head: aa, tail: bb, next: this.s, prev: null, closed: false};\n          if (this.s) {\n              this.s.prev = ma;\n          }\n          this.s = ma;\n\n          ++this.count;    // not essential - tracks number of unmerged sequences\n          break;\n\n      case 1:   // a matched, b did not - thus b extends sequence ma\n          var pp = {p: b};\n\n          if (prependA) {\n              pp.next = ma.head;\n              pp.prev = null;\n              ma.head.prev = pp;\n              ma.head = pp;\n          } else {\n              pp.next = null;\n              pp.prev = ma.tail;\n              ma.tail.next = pp;\n              ma.tail = pp;\n          }\n          break;\n\n      case 2:   // b matched, a did not - thus a extends sequence mb\n          var pp = {p: a};\n\n          if (prependB) {\n              pp.next = mb.head;\n              pp.prev = null;\n              mb.head.prev = pp;\n              mb.head = pp;\n          } else {\n              pp.next = null;\n              pp.prev = mb.tail;\n              mb.tail.next = pp;\n              mb.tail = pp;\n          }\n          break;\n\n      case 3:   // both matched, can merge sequences\n        // if the sequences are the same, do nothing, as we are simply closing this path (could set a flag)\n\n          if (ma === mb) {\n              var pp = {p: ma.tail.p, next: ma.head, prev: null};\n              ma.head.prev = pp;\n              ma.head = pp;\n              ma.closed = true;\n              break;\n          }\n\n        // there are 4 ways the sequence pair can be joined. The current setting of prependA and\n        // prependB will tell us which type of join is needed. For head/head and tail/tail joins\n        // one sequence needs to be reversed\n          switch ((prependA ? 1 : 0) | (prependB ? 2 : 0)) {\n          case 0:   // tail-tail\n            // reverse ma and append to mb\n              reverseList(ma);\n            // fall through to head/tail case\n          case 1:   // head-tail\n            // ma is appended to mb and ma discarded\n              mb.tail.next = ma.head;\n              ma.head.prev = mb.tail;\n              mb.tail = ma.tail;\n\n            //discard ma sequence record\n              this.remove_seq(ma);\n              break;\n\n          case 3:   // head-head\n            // reverse ma and append mb to it\n              reverseList(ma);\n            // fall through to tail/head case\n          case 2:   // tail-head\n            // mb is appended to ma and mb is discarded\n              ma.tail.next = mb.head;\n              mb.head.prev = ma.tail;\n              ma.tail = mb.tail;\n\n            //discard mb sequence record\n              this.remove_seq(mb);\n              break;\n          }\n      }\n  };\n\n  /*\n   * Implements CONREC.\n   *\n   * @private\n   * @param {function} drawContour function for drawing contour.  Defaults to a\n   *                               custom \"contour builder\", which populates the\n   *                               contours property.\n   */\n  function Conrec(drawContour) {\n      if (!drawContour) {\n          var c = this;\n          c.contours = {};\n      /**\n       * drawContour - interface for implementing the user supplied method to\n       * render the countours.\n       *\n       * Draws a line between the start and end coordinates.\n       *\n       * @private\n       * @param startX    - start coordinate for X\n       * @param startY    - start coordinate for Y\n       * @param endX      - end coordinate for X\n       * @param endY      - end coordinate for Y\n       * @param contourLevel - Contour level for line.\n       */\n          this.drawContour = function (startX, startY, endX, endY, contourLevel, k) {\n              var cb = c.contours[k];\n              if (!cb) {\n                  cb = c.contours[k] = new ContourBuilder(contourLevel);\n              }\n              cb.addSegment({x: startX, y: startY}, {x: endX, y: endY});\n          };\n          this.contourList = function () {\n              var l = [];\n              var a = c.contours;\n              for (var k in a) {\n                  var s = a[k].s;\n                  var level = a[k].level;\n                  while (s) {\n                      var h = s.head;\n                      var l2 = [];\n                      l2.level = level;\n                      l2.k = k;\n                      while (h && h.p) {\n                          l2.push(h.p);\n                          h = h.next;\n                      }\n                      l.push(l2);\n                      s = s.next;\n                  }\n              }\n              l.sort(function (a, b) { return a.k - b.k; });\n              return l;\n          };\n      } else {\n          this.drawContour = drawContour;\n      }\n      this.h  = new Array(5);\n      this.sh = new Array(5);\n      this.xh = new Array(5);\n      this.yh = new Array(5);\n  }\n\n  /*\n   * contour is a contouring subroutine for rectangularily spaced data\n   *\n   * It emits calls to a line drawing subroutine supplied by the user which\n   * draws a contour map corresponding to real*4data on a randomly spaced\n   * rectangular grid. The coordinates emitted are in the same units given in\n   * the x() and y() arrays.\n   *\n   * Any number of contour levels may be specified but they must be in order of\n   * increasing value.\n   *\n   *\n   * @param {number[][]} d - matrix of data to contour\n   * @param {number} ilb,iub,jlb,jub - index bounds of data matrix\n   *\n   *             The following two, one dimensional arrays (x and y) contain\n   *             the horizontal and vertical coordinates of each sample points.\n   * @param {number[]} x  - data matrix column coordinates\n   * @param {number[]} y  - data matrix row coordinates\n   * @param {number} nc   - number of contour levels\n   * @param {number[]} z  - contour levels in increasing order.\n   */\n  Conrec.prototype.contour = function (d, ilb, iub, jlb, jub, x, y, nc, z) {\n      var h = this.h, sh = this.sh, xh = this.xh, yh = this.yh;\n      var drawContour = this.drawContour;\n      this.contours = {};\n\n      var xsect = function (p1, p2) {\n          return (h[p2] * xh[p1] - h[p1] * xh[p2]) / (h[p2] - h[p1]);\n      };\n\n      var ysect = function (p1, p2) {\n          return (h[p2] * yh[p1] - h[p1] * yh[p2]) / (h[p2] - h[p1]);\n      };\n      var m1;\n      var m2;\n      var m3;\n      var case_value;\n      var dmin;\n      var dmax;\n      var x1 = 0.0;\n      var x2 = 0.0;\n      var y1 = 0.0;\n      var y2 = 0.0;\n\n    // The indexing of im and jm should be noted as it has to start from zero\n    // unlike the fortran counter part\n      var im = [0, 1, 1, 0];\n      var jm = [0, 0, 1, 1];\n\n    // Note that castab is arranged differently from the FORTRAN code because\n    // Fortran and C/C++ arrays are transposed of each other, in this case\n    // it is more tricky as castab is in 3 dimensions\n      var castab = [\n          [\n        [0, 0, 8], [0, 2, 5], [7, 6, 9]\n          ],\n          [\n        [0, 3, 4], [1, 3, 1], [4, 3, 0]\n          ],\n          [\n        [9, 6, 7], [5, 2, 0], [8, 0, 0]\n          ]\n      ];\n\n      for (var j = (jub - 1); j >= jlb; j--) {\n          for (var i = ilb; i <= iub - 1; i++) {\n              var temp1, temp2;\n              temp1 = Math.min(d[i][j], d[i][j + 1]);\n              temp2 = Math.min(d[i + 1][j], d[i + 1][j + 1]);\n              dmin  = Math.min(temp1, temp2);\n              temp1 = Math.max(d[i][j], d[i][j + 1]);\n              temp2 = Math.max(d[i + 1][j], d[i + 1][j + 1]);\n              dmax  = Math.max(temp1, temp2);\n\n              if (dmax >= z[0] && dmin <= z[nc - 1]) {\n                  for (var k = 0; k < nc; k++) {\n                      if (z[k] >= dmin && z[k] <= dmax) {\n                          for (var m = 4; m >= 0; m--) {\n                            if (m > 0) {\n                  // The indexing of im and jm should be noted as it has to\n                  // start from zero\n                              h[m] = d[i + im[m - 1]][j + jm[m - 1]] - z[k];\n                              xh[m] = x[i + im[m - 1]];\n                              yh[m] = y[j + jm[m - 1]];\n                          } else {\n                              h[0] = 0.25 * (h[1] + h[2] + h[3] + h[4]);\n                              xh[0] = 0.5 * (x[i] + x[i + 1]);\n                              yh[0] = 0.5 * (y[j] + y[j + 1]);\n                          }\n                            if (h[m] > EPSILON) {\n                              sh[m] = 1;\n                          } else if (h[m] < -EPSILON) {\n                            sh[m] = -1;\n                        } else\n                  sh[m] = 0;\n                        }\n              //\n              // Note: at this stage the relative heights of the corners and the\n              // centre are in the h array, and the corresponding coordinates are\n              // in the xh and yh arrays. The centre of the box is indexed by 0\n              // and the 4 corners by 1 to 4 as shown below.\n              // Each triangle is then indexed by the parameter m, and the 3\n              // vertices of each triangle are indexed by parameters m1,m2,and\n              // m3.\n              // It is assumed that the centre of the box is always vertex 2\n              // though this isimportant only when all 3 vertices lie exactly on\n              // the same contour level, in which case only the side of the box\n              // is drawn.\n              //\n              //\n              //      vertex 4 +-------------------+ vertex 3\n              //               | \\               / |\n              //               |   \\    m-3    /   |\n              //               |     \\       /     |\n              //               |       \\   /       |\n              //               |  m=2    X   m=2   |       the centre is vertex 0\n              //               |       /   \\       |\n              //               |     /       \\     |\n              //               |   /    m=1    \\   |\n              //               | /               \\ |\n              //      vertex 1 +-------------------+ vertex 2\n              //\n              //\n              //\n              //               Scan each triangle in the box\n              //\n                          for (m = 1; m <= 4; m++) {\n                            m1 = m;\n                            m2 = 0;\n                            if (m != 4) {\n                              m3 = m + 1;\n                          } else {\n                              m3 = 1;\n                          }\n                            case_value = castab[sh[m1] + 1][sh[m2] + 1][sh[m3] + 1];\n                            if (case_value != 0) {\n                              switch (case_value) {\n                            case 1: // Line between vertices 1 and 2\n                                x1 = xh[m1];\n                                y1 = yh[m1];\n                                x2 = xh[m2];\n                                y2 = yh[m2];\n                                break;\n                            case 2: // Line between vertices 2 and 3\n                                x1 = xh[m2];\n                                y1 = yh[m2];\n                                x2 = xh[m3];\n                                y2 = yh[m3];\n                                break;\n                            case 3: // Line between vertices 3 and 1\n                                x1 = xh[m3];\n                                y1 = yh[m3];\n                                x2 = xh[m1];\n                                y2 = yh[m1];\n                                break;\n                            case 4: // Line between vertex 1 and side 2-3\n                                x1 = xh[m1];\n                                y1 = yh[m1];\n                                x2 = xsect(m2, m3);\n                                y2 = ysect(m2, m3);\n                                break;\n                            case 5: // Line between vertex 2 and side 3-1\n                                x1 = xh[m2];\n                                y1 = yh[m2];\n                                x2 = xsect(m3, m1);\n                                y2 = ysect(m3, m1);\n                                break;\n                            case 6: //  Line between vertex 3 and side 1-2\n                                x1 = xh[m3];\n                                y1 = yh[m3];\n                                x2 = xsect(m1, m2);\n                                y2 = ysect(m1, m2);\n                                break;\n                            case 7: // Line between sides 1-2 and 2-3\n                                x1 = xsect(m1, m2);\n                                y1 = ysect(m1, m2);\n                                x2 = xsect(m2, m3);\n                                y2 = ysect(m2, m3);\n                                break;\n                            case 8: // Line between sides 2-3 and 3-1\n                                x1 = xsect(m2, m3);\n                                y1 = ysect(m2, m3);\n                                x2 = xsect(m3, m1);\n                                y2 = ysect(m3, m1);\n                                break;\n                            case 9: // Line between sides 3-1 and 1-2\n                                x1 = xsect(m3, m1);\n                                y1 = ysect(m3, m1);\n                                x2 = xsect(m1, m2);\n                                y2 = ysect(m1, m2);\n                                break;\n                            default:\n                                break;\n                            }\n                  // Put your processing code here and comment out the printf\n                  //printf(\"%f %f %f %f %f\\n\",x1,y1,x2,y2,z[k]);\n                              drawContour(x1, y1, x2, y2, z[k], k);\n                          }\n                        }\n                      }\n                  }\n              }\n          }\n      }\n  };\n"]},"metadata":{},"sourceType":"script"}