{"ast":null,"code":"/**\n * Takes a {@link Polygon|polygon} and returns {@link Point|points} at all self-intersections.\n *\n * @name kinks\n * @param {Feature<Polygon>|Polygon} polygon input polygon\n * @returns {FeatureCollection<Point>} self-intersections\n * @example\n * var poly = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Polygon\",\n *     \"coordinates\": [[\n *       [-12.034835, 8.901183],\n *       [-12.060413, 8.899826],\n *       [-12.03638, 8.873199],\n *       [-12.059383, 8.871418],\n *       [-12.034835, 8.901183]\n *     ]]\n *   }\n * };\n *\n * var kinks = turf.kinks(poly);\n *\n * var resultFeatures = kinks.intersections.features.concat(poly);\n * var result = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": resultFeatures\n * };\n *\n * //=result\n */\nvar point = require('turf-helpers').point;\n\nmodule.exports = function (polyIn) {\n  var poly;\n  var results = {\n    type: 'FeatureCollection',\n    features: []\n  };\n\n  if (polyIn.type === 'Feature') {\n    poly = polyIn.geometry;\n  } else {\n    poly = polyIn;\n  }\n\n  poly.coordinates.forEach(function (ring1) {\n    poly.coordinates.forEach(function (ring2) {\n      for (var i = 0; i < ring1.length - 1; i++) {\n        for (var k = 0; k < ring2.length - 1; k++) {\n          // don't check adjacent sides of a given ring, since of course they intersect in a vertex.\n          if (ring1 === ring2 && (Math.abs(i - k) === 1 || Math.abs(i - k) === ring1.length - 2)) {\n            continue;\n          }\n\n          var intersection = lineIntersects(ring1[i][0], ring1[i][1], ring1[i + 1][0], ring1[i + 1][1], ring2[k][0], ring2[k][1], ring2[k + 1][0], ring2[k + 1][1]);\n\n          if (intersection) {\n            results.features.push(point([intersection[0], intersection[1]]));\n          }\n        }\n      }\n    });\n  });\n  return results;\n}; // modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/\n\n\nfunction lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {\n  // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point\n  var denominator,\n      a,\n      b,\n      numerator1,\n      numerator2,\n      result = {\n    x: null,\n    y: null,\n    onLine1: false,\n    onLine2: false\n  };\n  denominator = (line2EndY - line2StartY) * (line1EndX - line1StartX) - (line2EndX - line2StartX) * (line1EndY - line1StartY);\n\n  if (denominator === 0) {\n    if (result.x !== null && result.y !== null) {\n      return result;\n    } else {\n      return false;\n    }\n  }\n\n  a = line1StartY - line2StartY;\n  b = line1StartX - line2StartX;\n  numerator1 = (line2EndX - line2StartX) * a - (line2EndY - line2StartY) * b;\n  numerator2 = (line1EndX - line1StartX) * a - (line1EndY - line1StartY) * b;\n  a = numerator1 / denominator;\n  b = numerator2 / denominator; // if we cast these lines infinitely in both directions, they intersect here:\n\n  result.x = line1StartX + a * (line1EndX - line1StartX);\n  result.y = line1StartY + a * (line1EndY - line1StartY); // if line1 is a segment and line2 is infinite, they intersect if:\n\n  if (a >= 0 && a <= 1) {\n    result.onLine1 = true;\n  } // if line2 is a segment and line1 is infinite, they intersect if:\n\n\n  if (b >= 0 && b <= 1) {\n    result.onLine2 = true;\n  } // if line1 and line2 are segments, they intersect if both of the above are true\n\n\n  if (result.onLine1 && result.onLine2) {\n    return [result.x, result.y];\n  } else {\n    return false;\n  }\n}","map":{"version":3,"sources":["/Users/yiqianyao/workspace/something/floorcanvas/node_modules/turf-kinks/index.js"],"names":["point","require","module","exports","polyIn","poly","results","type","features","geometry","coordinates","forEach","ring1","ring2","i","length","k","Math","abs","intersection","lineIntersects","push","line1StartX","line1StartY","line1EndX","line1EndY","line2StartX","line2StartY","line2EndX","line2EndY","denominator","a","b","numerator1","numerator2","result","x","y","onLine1","onLine2"],"mappings":"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","sourcesContent":["/**\n * Takes a {@link Polygon|polygon} and returns {@link Point|points} at all self-intersections.\n *\n * @name kinks\n * @param {Feature<Polygon>|Polygon} polygon input polygon\n * @returns {FeatureCollection<Point>} self-intersections\n * @example\n * var poly = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Polygon\",\n *     \"coordinates\": [[\n *       [-12.034835, 8.901183],\n *       [-12.060413, 8.899826],\n *       [-12.03638, 8.873199],\n *       [-12.059383, 8.871418],\n *       [-12.034835, 8.901183]\n *     ]]\n *   }\n * };\n *\n * var kinks = turf.kinks(poly);\n *\n * var resultFeatures = kinks.intersections.features.concat(poly);\n * var result = {\n *   \"type\": \"FeatureCollection\",\n *   \"features\": resultFeatures\n * };\n *\n * //=result\n */\n\nvar point = require('turf-helpers').point;\n\nmodule.exports = function (polyIn) {\n    var poly;\n    var results = {\n        type: 'FeatureCollection',\n        features: []\n    };\n    if (polyIn.type === 'Feature') {\n        poly = polyIn.geometry;\n    } else {\n        poly = polyIn;\n    }\n    poly.coordinates.forEach(function (ring1) {\n        poly.coordinates.forEach(function (ring2) {\n            for (var i = 0; i < ring1.length - 1; i++) {\n                for (var k = 0; k < ring2.length - 1; k++) {\n                    // don't check adjacent sides of a given ring, since of course they intersect in a vertex.\n                    if (ring1 === ring2 && (Math.abs(i - k) === 1 || Math.abs(i - k) === ring1.length - 2)) {\n                        continue;\n                    }\n\n                    var intersection = lineIntersects(ring1[i][0], ring1[i][1], ring1[i + 1][0], ring1[i + 1][1],\n                        ring2[k][0], ring2[k][1], ring2[k + 1][0], ring2[k + 1][1]);\n                    if (intersection) {\n                        results.features.push(point([intersection[0], intersection[1]]));\n                    }\n                }\n            }\n        });\n    });\n    return results;\n};\n\n\n// modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/\nfunction lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {\n    // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point\n    var denominator, a, b, numerator1, numerator2,\n        result = {\n            x: null,\n            y: null,\n            onLine1: false,\n            onLine2: false\n        };\n    denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));\n    if (denominator === 0) {\n        if (result.x !== null && result.y !== null) {\n            return result;\n        } else {\n            return false;\n        }\n    }\n    a = line1StartY - line2StartY;\n    b = line1StartX - line2StartX;\n    numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);\n    numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);\n    a = numerator1 / denominator;\n    b = numerator2 / denominator;\n\n    // if we cast these lines infinitely in both directions, they intersect here:\n    result.x = line1StartX + (a * (line1EndX - line1StartX));\n    result.y = line1StartY + (a * (line1EndY - line1StartY));\n\n    // if line1 is a segment and line2 is infinite, they intersect if:\n    if (a >= 0 && a <= 1) {\n        result.onLine1 = true;\n    }\n    // if line2 is a segment and line1 is infinite, they intersect if:\n    if (b >= 0 && b <= 1) {\n        result.onLine2 = true;\n    }\n    // if line1 and line2 are segments, they intersect if both of the above are true\n    if (result.onLine1 && result.onLine2) {\n        return [result.x, result.y];\n    } else {\n        return false;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}