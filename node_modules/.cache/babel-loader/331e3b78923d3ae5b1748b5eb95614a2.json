{"ast":null,"code":"/*\n (c) 2017, Vladimir Agafonkin\n Simplify.js, a high-performance JS polyline simplification library\n mourner.github.io/simplify-js\n*/\n(function () {\n  'use strict'; // to suit your point format, run search/replace for '.x' and '.y';\n  // for 3D version, see 3d branch (configurability would draw significant performance overhead)\n  // square distance between 2 points\n\n  function getSqDist(p1, p2) {\n    var dx = p1.x - p2.x,\n        dy = p1.y - p2.y;\n    return dx * dx + dy * dy;\n  } // square distance from a point to a segment\n\n\n  function getSqSegDist(p, p1, p2) {\n    var x = p1.x,\n        y = p1.y,\n        dx = p2.x - x,\n        dy = p2.y - y;\n\n    if (dx !== 0 || dy !== 0) {\n      var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);\n\n      if (t > 1) {\n        x = p2.x;\n        y = p2.y;\n      } else if (t > 0) {\n        x += dx * t;\n        y += dy * t;\n      }\n    }\n\n    dx = p.x - x;\n    dy = p.y - y;\n    return dx * dx + dy * dy;\n  } // rest of the code doesn't care about point format\n  // basic distance-based simplification\n\n\n  function simplifyRadialDist(points, sqTolerance) {\n    var prevPoint = points[0],\n        newPoints = [prevPoint],\n        point;\n\n    for (var i = 1, len = points.length; i < len; i++) {\n      point = points[i];\n\n      if (getSqDist(point, prevPoint) > sqTolerance) {\n        newPoints.push(point);\n        prevPoint = point;\n      }\n    }\n\n    if (prevPoint !== point) newPoints.push(point);\n    return newPoints;\n  }\n\n  function simplifyDPStep(points, first, last, sqTolerance, simplified) {\n    var maxSqDist = sqTolerance,\n        index;\n\n    for (var i = first + 1; i < last; i++) {\n      var sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n      if (sqDist > maxSqDist) {\n        index = i;\n        maxSqDist = sqDist;\n      }\n    }\n\n    if (maxSqDist > sqTolerance) {\n      if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);\n      simplified.push(points[index]);\n      if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);\n    }\n  } // simplification using Ramer-Douglas-Peucker algorithm\n\n\n  function simplifyDouglasPeucker(points, sqTolerance) {\n    var last = points.length - 1;\n    var simplified = [points[0]];\n    simplifyDPStep(points, 0, last, sqTolerance, simplified);\n    simplified.push(points[last]);\n    return simplified;\n  } // both algorithms combined for awesome performance\n\n\n  function simplify(points, tolerance, highestQuality) {\n    if (points.length <= 2) return points;\n    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n    points = simplifyDouglasPeucker(points, sqTolerance);\n    return points;\n  } // export as AMD module / Node module / browser or worker variable\n\n\n  if (typeof define === 'function' && define.amd) define(function () {\n    return simplify;\n  });else if (typeof module !== 'undefined') {\n    module.exports = simplify;\n    module.exports.default = simplify;\n  } else if (typeof self !== 'undefined') self.simplify = simplify;else window.simplify = simplify;\n})();","map":{"version":3,"sources":["/Users/yiqianyao/workspace/something/floorcanvas/node_modules/simplify-js/simplify.js"],"names":["getSqDist","p1","p2","dx","x","dy","y","getSqSegDist","p","t","simplifyRadialDist","points","sqTolerance","prevPoint","newPoints","point","i","len","length","push","simplifyDPStep","first","last","simplified","maxSqDist","index","sqDist","simplifyDouglasPeucker","simplify","tolerance","highestQuality","undefined","define","amd","module","exports","default","self","window"],"mappings":"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","sourcesContent":["/*\n (c) 2017, Vladimir Agafonkin\n Simplify.js, a high-performance JS polyline simplification library\n mourner.github.io/simplify-js\n*/\n\n(function () { 'use strict';\n\n// to suit your point format, run search/replace for '.x' and '.y';\n// for 3D version, see 3d branch (configurability would draw significant performance overhead)\n\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n\n    var dx = p1.x - p2.x,\n        dy = p1.y - p2.y;\n\n    return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(p, p1, p2) {\n\n    var x = p1.x,\n        y = p1.y,\n        dx = p2.x - x,\n        dy = p2.y - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = p2.x;\n            y = p2.y;\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = p.x - x;\n    dy = p.y - y;\n\n    return dx * dx + dy * dy;\n}\n// rest of the code doesn't care about point format\n\n// basic distance-based simplification\nfunction simplifyRadialDist(points, sqTolerance) {\n\n    var prevPoint = points[0],\n        newPoints = [prevPoint],\n        point;\n\n    for (var i = 1, len = points.length; i < len; i++) {\n        point = points[i];\n\n        if (getSqDist(point, prevPoint) > sqTolerance) {\n            newPoints.push(point);\n            prevPoint = point;\n        }\n    }\n\n    if (prevPoint !== point) newPoints.push(point);\n\n    return newPoints;\n}\n\nfunction simplifyDPStep(points, first, last, sqTolerance, simplified) {\n    var maxSqDist = sqTolerance,\n        index;\n\n    for (var i = first + 1; i < last; i++) {\n        var sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n        if (sqDist > maxSqDist) {\n            index = i;\n            maxSqDist = sqDist;\n        }\n    }\n\n    if (maxSqDist > sqTolerance) {\n        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);\n        simplified.push(points[index]);\n        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);\n    }\n}\n\n// simplification using Ramer-Douglas-Peucker algorithm\nfunction simplifyDouglasPeucker(points, sqTolerance) {\n    var last = points.length - 1;\n\n    var simplified = [points[0]];\n    simplifyDPStep(points, 0, last, sqTolerance, simplified);\n    simplified.push(points[last]);\n\n    return simplified;\n}\n\n// both algorithms combined for awesome performance\nfunction simplify(points, tolerance, highestQuality) {\n\n    if (points.length <= 2) return points;\n\n    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n\n    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n    points = simplifyDouglasPeucker(points, sqTolerance);\n\n    return points;\n}\n\n// export as AMD module / Node module / browser or worker variable\nif (typeof define === 'function' && define.amd) define(function() { return simplify; });\nelse if (typeof module !== 'undefined') {\n    module.exports = simplify;\n    module.exports.default = simplify;\n} else if (typeof self !== 'undefined') self.simplify = simplify;\nelse window.simplify = simplify;\n\n})();\n"]},"metadata":{},"sourceType":"script"}