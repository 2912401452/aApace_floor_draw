{"ast":null,"code":"var point = require('turf-helpers').point;\n\nvar polygon = require('turf-helpers').polygon;\n\nvar distance = require('turf-distance');\n\nvar featurecollection = require('turf-helpers').featureCollection; //Precompute cosines and sines of angles used in hexagon creation\n// for performance gain\n\n\nvar cosines = [];\nvar sines = [];\n\nfor (var i = 0; i < 6; i++) {\n  var angle = 2 * Math.PI / 6 * i;\n  cosines.push(Math.cos(angle));\n  sines.push(Math.sin(angle));\n}\n/**\n * Takes a bounding box and a cell size in degrees and returns a {@link FeatureCollection} of flat-topped\n * hexagons ({@link Polygon} features) aligned in an \"odd-q\" vertical grid as\n * described in [Hexagonal Grids](http://www.redblobgames.com/grids/hexagons/).\n *\n * @name hexGrid\n * @param {Array<number>} bbox bounding box in [minX, minY, maxX, maxY] order\n * @param {number} cellSize dimension of cell in specified units\n * @param {string} units used in calculating cellWidth ('miles' or 'kilometers')\n * @param {boolean} triangles whether to return as triangles instead of hexagons\n * @return {FeatureCollection<Polygon>} a hexagonal grid\n * @example\n * var bbox = [-96,31,-84,40];\n * var cellWidth = 50;\n * var units = 'miles';\n *\n * var hexgrid = turf.hexGrid(bbox, cellWidth, units);\n *\n * //=hexgrid\n */\n\n\nmodule.exports = function hexGrid(bbox, cellSize, units, triangles) {\n  var xFraction = cellSize / distance(point([bbox[0], bbox[1]]), point([bbox[2], bbox[1]]), units);\n  var cellWidth = xFraction * (bbox[2] - bbox[0]);\n  var yFraction = cellSize / distance(point([bbox[0], bbox[1]]), point([bbox[0], bbox[3]]), units);\n  var cellHeight = yFraction * (bbox[3] - bbox[1]);\n  var radius = cellWidth / 2;\n  var hex_width = radius * 2;\n  var hex_height = Math.sqrt(3) / 2 * cellHeight;\n  var box_width = bbox[2] - bbox[0];\n  var box_height = bbox[3] - bbox[1];\n  var x_interval = 3 / 4 * hex_width;\n  var y_interval = hex_height;\n  var x_span = box_width / (hex_width - radius / 2);\n  var x_count = Math.ceil(x_span);\n\n  if (Math.round(x_span) === x_count) {\n    x_count++;\n  }\n\n  var x_adjust = (x_count * x_interval - radius / 2 - box_width) / 2 - radius / 2;\n  var y_count = Math.ceil(box_height / hex_height);\n  var y_adjust = (box_height - y_count * hex_height) / 2;\n  var hasOffsetY = y_count * hex_height - box_height > hex_height / 2;\n\n  if (hasOffsetY) {\n    y_adjust -= hex_height / 4;\n  }\n\n  var fc = featurecollection([]);\n\n  for (var x = 0; x < x_count; x++) {\n    for (var y = 0; y <= y_count; y++) {\n      var isOdd = x % 2 === 1;\n\n      if (y === 0 && isOdd) {\n        continue;\n      }\n\n      if (y === 0 && hasOffsetY) {\n        continue;\n      }\n\n      var center_x = x * x_interval + bbox[0] - x_adjust;\n      var center_y = y * y_interval + bbox[1] + y_adjust;\n\n      if (isOdd) {\n        center_y -= hex_height / 2;\n      }\n\n      if (triangles) {\n        fc.features.push.apply(fc.features, hexTriangles([center_x, center_y], cellWidth / 2, cellHeight / 2));\n      } else {\n        fc.features.push(hexagon([center_x, center_y], cellWidth / 2, cellHeight / 2));\n      }\n    }\n  }\n\n  return fc;\n}; //Center should be [x, y]\n\n\nfunction hexagon(center, rx, ry) {\n  var vertices = [];\n\n  for (var i = 0; i < 6; i++) {\n    var x = center[0] + rx * cosines[i];\n    var y = center[1] + ry * sines[i];\n    vertices.push([x, y]);\n  } //first and last vertex must be the same\n\n\n  vertices.push(vertices[0]);\n  return polygon([vertices]);\n} //Center should be [x, y]\n\n\nfunction hexTriangles(center, rx, ry) {\n  var triangles = [];\n\n  for (var i = 0; i < 6; i++) {\n    var vertices = [];\n    vertices.push(center);\n    vertices.push([center[0] + rx * cosines[i], center[1] + ry * sines[i]]);\n    vertices.push([center[0] + rx * cosines[(i + 1) % 6], center[1] + ry * sines[(i + 1) % 6]]);\n    vertices.push(center);\n    triangles.push(polygon([vertices]));\n  }\n\n  return triangles;\n}","map":{"version":3,"sources":["/Users/yiqianyao/workspace/something/aApace_floor_draw/node_modules/turf-hex-grid/index.js"],"names":["point","require","polygon","distance","featurecollection","featureCollection","cosines","sines","i","angle","Math","PI","push","cos","sin","module","exports","hexGrid","bbox","cellSize","units","triangles","xFraction","cellWidth","yFraction","cellHeight","radius","hex_width","hex_height","sqrt","box_width","box_height","x_interval","y_interval","x_span","x_count","ceil","round","x_adjust","y_count","y_adjust","hasOffsetY","fc","x","y","isOdd","center_x","center_y","features","apply","hexTriangles","hexagon","center","rx","ry","vertices"],"mappings":"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","sourcesContent":["var point = require('turf-helpers').point;\nvar polygon = require('turf-helpers').polygon;\nvar distance = require('turf-distance');\nvar featurecollection = require('turf-helpers').featureCollection;\n\n//Precompute cosines and sines of angles used in hexagon creation\n// for performance gain\nvar cosines = [];\nvar sines = [];\nfor (var i = 0; i < 6; i++) {\n    var angle = 2 * Math.PI / 6 * i;\n    cosines.push(Math.cos(angle));\n    sines.push(Math.sin(angle));\n}\n\n/**\n * Takes a bounding box and a cell size in degrees and returns a {@link FeatureCollection} of flat-topped\n * hexagons ({@link Polygon} features) aligned in an \"odd-q\" vertical grid as\n * described in [Hexagonal Grids](http://www.redblobgames.com/grids/hexagons/).\n *\n * @name hexGrid\n * @param {Array<number>} bbox bounding box in [minX, minY, maxX, maxY] order\n * @param {number} cellSize dimension of cell in specified units\n * @param {string} units used in calculating cellWidth ('miles' or 'kilometers')\n * @param {boolean} triangles whether to return as triangles instead of hexagons\n * @return {FeatureCollection<Polygon>} a hexagonal grid\n * @example\n * var bbox = [-96,31,-84,40];\n * var cellWidth = 50;\n * var units = 'miles';\n *\n * var hexgrid = turf.hexGrid(bbox, cellWidth, units);\n *\n * //=hexgrid\n */\nmodule.exports = function hexGrid(bbox, cellSize, units, triangles) {\n    var xFraction = cellSize / (distance(point([bbox[0], bbox[1]]), point([bbox[2], bbox[1]]), units));\n    var cellWidth = xFraction * (bbox[2] - bbox[0]);\n    var yFraction = cellSize / (distance(point([bbox[0], bbox[1]]), point([bbox[0], bbox[3]]), units));\n    var cellHeight = yFraction * (bbox[3] - bbox[1]);\n    var radius = cellWidth / 2;\n\n    var hex_width = radius * 2;\n    var hex_height = Math.sqrt(3) / 2 * cellHeight;\n\n    var box_width = bbox[2] - bbox[0];\n    var box_height = bbox[3] - bbox[1];\n\n    var x_interval = 3 / 4 * hex_width;\n    var y_interval = hex_height;\n\n    var x_span = box_width / (hex_width - radius / 2);\n    var x_count = Math.ceil(x_span);\n    if (Math.round(x_span) === x_count) {\n        x_count++;\n    }\n\n    var x_adjust = ((x_count * x_interval - radius / 2) - box_width) / 2 - radius / 2;\n\n    var y_count = Math.ceil(box_height / hex_height);\n\n    var y_adjust = (box_height - y_count * hex_height) / 2;\n\n    var hasOffsetY = y_count * hex_height - box_height > hex_height / 2;\n    if (hasOffsetY) {\n        y_adjust -= hex_height / 4;\n    }\n\n    var fc = featurecollection([]);\n    for (var x = 0; x < x_count; x++) {\n        for (var y = 0; y <= y_count; y++) {\n\n            var isOdd = x % 2 === 1;\n            if (y === 0 && isOdd) {\n                continue;\n            }\n\n            if (y === 0 && hasOffsetY) {\n                continue;\n            }\n\n            var center_x = x * x_interval + bbox[0] - x_adjust;\n            var center_y = y * y_interval + bbox[1] + y_adjust;\n\n            if (isOdd) {\n                center_y -= hex_height / 2;\n            }\n            if (triangles) {\n                fc.features.push.apply(fc.features, hexTriangles([center_x, center_y], cellWidth / 2, cellHeight / 2));\n            } else {\n                fc.features.push(hexagon([center_x, center_y], cellWidth / 2, cellHeight / 2));\n            }\n        }\n    }\n\n    return fc;\n};\n\n//Center should be [x, y]\nfunction hexagon(center, rx, ry) {\n    var vertices = [];\n    for (var i = 0; i < 6; i++) {\n        var x = center[0] + rx * cosines[i];\n        var y = center[1] + ry * sines[i];\n        vertices.push([x, y]);\n    }\n    //first and last vertex must be the same\n    vertices.push(vertices[0]);\n    return polygon([vertices]);\n}\n\n//Center should be [x, y]\nfunction hexTriangles(center, rx, ry) {\n    var triangles = [];\n    for (var i = 0; i < 6; i++) {\n        var vertices = [];\n        vertices.push(center);\n        vertices.push([\n            center[0] + rx * cosines[i],\n            center[1] + ry * sines[i]\n        ]);\n        vertices.push([\n            center[0] + rx * cosines[(i + 1) % 6],\n            center[1] + ry * sines[(i + 1) % 6]\n        ]);\n        vertices.push(center);\n        triangles.push(polygon([vertices]));\n    }\n    return triangles;\n}\n"]},"metadata":{},"sourceType":"script"}